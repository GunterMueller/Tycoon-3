<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
   <TITLE></TITLE>
   <META NAME="GENERATOR" CONTENT="Mozilla/3.0Gold (X11; I; SunOS 5.5.1 sun4m) [Netscape]">
</HEAD>
<BODY>

<H1>checking ...</H1>

<H2>... a <A NAME="class"></A>class:</H2>

<UL>
<P><TT>class C(P &lt;: B(BP))<BR>
super S(SP)<BR>
metaclass M(MP)<BR>
Self &lt;: SS(SSP)<BR>
...</TT><BR>
<BR>
</P>

<P>check</P>

<LI><A HREF="#signatures">well-formedness of parameter signatures</A> (<TT>B(BP)</TT>)</LI>

<LI><A HREF="#type">well-formedness of super type declaration</A> (<TT>S(SP)</TT>)</LI>

<LI><A HREF="#signatures">well-formedness of Self signature</A></LI>

<LI><A HREF="#TL2CPL">TL2CPL</A></LI>

<LI><A HREF="#type">well-formedness of the metaclass type</A> and that
it is a closed type ( &lt;: Void )</LI>

<LI>for every method, check:</LI>

<UL>
<LI><A HREF="#signatures">well-formedness of parameter signatures</A></LI>

<LI><A HREF="#type">return type</A></LI>

<LI>type of body &lt;: declared return type</LI>
</UL>
</UL>

<H2>... <A NAME="signatures"></A>signature(s):</H2>

<UL>
<P><TT>x :X<BR>
A &lt;: O(P)<BR>
A = O(P)&nbsp;??</TT></P>

<P>check</P>

<LI>whether it is in the right context: value, type-signature</LI>

<LI><A HREF="#type">well-formedness of type</A></LI>
</UL>

<H2>... <A NAME="TL2CPL"></A>TL2CPL:</H2>

<UL>
<P><TT>X(A).Y(B).Z(C).Object[.TL2Pool]</TT></P>

<LI>recursively check the tail TL2CPL</LI>

<LI><I>(with </I>original class<I> denoting the head of the TL2CPL at the
first invocation, and </I>class <I>denoting the head of the current TL2CPL):</I></LI>

<LI><A HREF="#type">## check the well-formedness of the class<BR>
</A>## why this ? Only check the direct supers of a class</LI>

<LI>check whether the original class ( the head at the first invocation
) complies to the Self signature of the class (only if original class is
not abstract. <B>WHY ?</B> (why bother if there will be no instances of
this class))</LI>

<LI>check whether the class is subtype of the TL2CPL-type formed by tail:</LI>

<UL>
<LI>thereby substituting Self in the TL2CPL-type with the Self-type of the
original class</LI>

<LI>check for every method that its type is subtype of the corresponding
overridden version in the TL2CPL-type</LI>
</UL>
</UL>

<H2>... <A NAME="type"></A>type:</H2>

<UL>
<P><TT>List(T)</TT></P>

<LI>A typeIde is well-formed</LI>

<LI>Wrong is well-formed</LI>

<LI>Nil is well-formed</LI>

<LI>A unification variable is well-formed, iff </LI>

<UL>
<LI>its bound is well-formed</LI>

<LI>its instantiation is well-formed (always true <I>???</I>)</LI>
</UL>

<LI>A method type is well-formed, iff</LI>

<UL>
<LI>its <A HREF="#signatures">signatures are well-formed</A> </LI>

<LI>its return type is well-formed</LI>
</UL>

<LI>A method suite (aka object type) is well-formed iff </LI>

<UL>
<LI>its Self signature bound is well-formed </LI>

<LI>all its method types are well-formed</LI>
</UL>

<LI>A Var type is well-formed iff its parameter is well-formed</LI>

<LI>A type application is well-formed iff</LI>

<UL>
<LI>the applyee (???) is an oper</LI>

<LI>the formal parameters comply to the signatures of the oper</LI>
</UL>

<LI>A type operator is well-formed iff</LI>

<UL>
<LI><A HREF="#signatures">its signatures are well-formed</A></LI>

<LI>its range is well-formed</LI>
</UL>
</UL>

<H2>... <A NAME="subtype"></A>subtype:</H2>

<UL>
<P><TT>T &lt;: Sortable(T)</TT></P>
</UL>

<CENTER><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=0 >
<TR ALIGN=CENTER VALIGN=CENTER>
<TD>
<UL>
<P>Big</P>
</UL>

<P>Small</P>
</TD>

<TD>Nil</TD>

<TD>Object-<BR>
TL2Type</TD>

<TD>Apply-<BR>
TL2Type</TD>

<TD>TL2IdeType</TD>

<TD>Unify-<BR>
TL2Type</TD>

<TD>TL2OperType</TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD>Nil</TD>

<TD><FONT COLOR="#7CFC00">XX</FONT></TD>

<TD ALIGN=CENTER VALIGN=CENTER><FONT COLOR="#7CFC00">XX</FONT></TD>

<TD><FONT COLOR="#7CFC00">XX</FONT></TD>

<TD>b</TD>

<TD>Inst</TD>

<TD><FONT COLOR="#FF0000">FF</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD>TL2ObjectType</TD>

<TD><FONT COLOR="#FF0000">FF</FONT></TD>

<TD><B><FONT COLOR="#191970">rule</FONT></B></TD>

<TD>b</TD>

<TD>b</TD>

<TD>Inst</TD>

<TD><FONT COLOR="#FF0000">FF</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD>TL2ApplyType</TD>

<TD><FONT COLOR="#FF0000">FF</FONT></TD>

<TD>s</TD>

<TD><B><FONT COLOR="#191970">rule</FONT></B></TD>

<TD>b</TD>

<TD>Inst</TD>

<TD><FONT COLOR="#FF0000">FF</FONT></TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD>TL2IdeType</TD>

<TD>s</TD>

<TD>s</TD>

<TD>s</TD>

<TD>== / s / b</TD>

<TD>Inst</TD>

<TD>s</TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD>TL2UnifyType</TD>

<TD>Inst</TD>

<TD>Inst</TD>

<TD>Inst</TD>

<TD>Inst</TD>

<TD>Inst</TD>

<TD>Inst</TD>
</TR>

<TR ALIGN=CENTER VALIGN=CENTER>
<TD>TL2OperType</TD>

<TD><FONT COLOR="#FF0000">FF</FONT></TD>

<TD><FONT COLOR="#FF0000">FF</FONT></TD>

<TD><FONT COLOR="#FF0000">FF</FONT></TD>

<TD>b</TD>

<TD>Inst</TD>

<TD><B><FONT COLOR="#191970">rule</FONT></B></TD>
</TR>
</TABLE></CENTER>

<P>SubNil</P>

<PRE> |- T &lt;: Void
--------------
 |- Nil &lt;: T</PRE>

<H2>... <A NAME="value"></A>value:</H2>

<UL>
<P><TT>3 &gt;&nbsp;2 ?&nbsp;{&nbsp;&quot;Yes&quot; } :&nbsp;{&nbsp;&quot;No&quot;&nbsp;}</TT></P>

<LI>TL2AssertValue: check that <A HREF="#subtype">value's type is subtype
of Bool</A>, result is Void</LI>

<LI>TL2AssignValue: check that <A HREF="#subtype">value's type is subtype
of the ide's type</A>, result is that type.</LI>

<LI>TL2BlockValue: check all types, result is last value's type, Void if empty
block</LI>

<LI>TL2Bool2Value ( And, Or, Xor ): check that <A HREF="#subtype">both operands'
types are subtype of Bool</A>, result is Bool</LI>

<LI>TL2IdeValue: result is declared/inferred type</LI>

<LI>TL2IfValue: check that <A HREF="#subtype">condition's type is subtype
of Boo</A>l, result is Void</LI>

<LI>?TL2Value: this is a send to Bool</LI>

<LI>TL2LetValue: Maybe introduce a UniVar, check that <A HREF="#subtype">assigned
value's type (if any) is subtype of the declared type</A>, result is the
declared type</LI>

<LI>TL2LiteralValue: result is the type of the literal</LI>

<LI>TL2SendValue: lookup method, check bindings vs method signatures, result
is method's range</LI>

<LI>TL2SuperSendValue: lookup method in TL2CPL type, ...</LI>

<LI>TL2TryValue: check body, check handler, result is Void</LI>

<LI>LoopValue:<BR>
<TT>while(x &gt; 0) { result := result +&nbsp;a[x], --x, result } : Int
?<BR>
</TT>check that <A HREF="#subtype">condition's type is subtype of Bool</A>,
check body, result is Void ( or type of body ).</LI>
</UL>

<P>
<HR WIDTH="100%"></P>

<H2>Implementation</H2>

<UL>
<LI>there is a class for every type in the AST:</LI>

<UL>
<LI>TL2IdeType ( identifiers as types : String )</LI>

<LI>TL2ApplyType ( appearant applications of type opers to type arguments
: List(String)</LI>

<LI>TL2NilType</LI>
</UL>

<LI>additional types:</LI>

<UL>
<LI>TL2ObjectType (introduced by the TL2TypeChecker for every class)</LI>

<LI>TL2OperType (introduced by the TL2TypeChecker for every parameterized class)</LI>

<LI>TL2VoidType (a special, empty methodsuite)</LI>

<LI>TL2MethodType (allocated by the TL2ClassManager )</LI>

<LI>TL2SubstType (introduced by the TL2TypeChecker if the range of a substitution
is to be constrained to a single type, see note below)</LI>

<LI>TL2UnifyType ( introduced by the TL2TypeChecker for type inference for omitted
types at</LI>

<UL>
<LI>let-bindings: <TT>let x = expr</TT></LI>

<LI>method-calls: <TT>cond ?&nbsp;{ ifTrue }&nbsp;:&nbsp;{ ifFalse }</TT></LI>
</UL>

<LI>TL2CPLType ( by the compiler for types in the <TT>super</TT> list of classes
)</LI>
</UL>
</UL>

<H3>
<HR WIDTH="100%"></H3>

<H3>Notes</H3>

<UL>
<LI><B>justify <I>uninherited</I> methods (TL2OperType.lookup, TL2OperType.methods)</B></LI>

<LI><B>how is the environment represented in the typechecker ?</B></LI>

<LI>method lookup in CPLTypes</LI>

<LI>how to handle Self in lookup ?</LI>

<LI><B>what is to be stored in the subtype-DB&nbsp;?</B></LI>

<UL>
<LI>IdeTypes</LI>

<LI>ApplyTypes with IdeTypes</LI>

<LI>Types WITH substitutions or WITHOUT (meaning the empty subst)<BR>
note that T1 &lt;:&nbsp;T2 =&gt; s(T1) &lt;: s(T2) (with s conforming to
the Ides' declarations)</LI>
</UL>
</UL>

<ADDRESS>Matthias Ernst, 26.2.97</ADDRESS>

</BODY>
</HTML>
