(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *

Data about properties of the associated SQL-Statement

Author:  Michael Skusa

Date:    16-Aug-1996

Updates: (Date)		(Name)	(Description)
	 14-mar-1997	MS	replaced integers for return-, type- and
				error-codes with named constants
*)

class OCICursorMetaData

super SQLCursorMetaData

metaclass SimpleConcreteClass(OCICursorMetaData)

public

hdbc:Int32

methods

retrieveColumnData(hstmt:Int32)
{
  (* create GapArrays, because number of columns is not known *)
  let var columnCount=0,
  let columnNames:GapArray(String) = GapArray.new(columnCount),
  let nulls:GapArray(Bool) = GapArray.new(columnCount),
  let precisions:GapArray(Int) = GapArray.new(columnCount),
  let scales:GapArray(Int) = GapArray.new(columnCount),
  let types:GapArray(Int) = GapArray.new(columnCount),

  (* allocate valueholder for the odescr-call *)
  let maxNameLength = 100,
  let dbsize = CIntHolder.new,
  let dbtype = CShortHolder.new,
  let cbuf = CStringHolder.new(maxNameLength),
  let cbufl = CIntHolder.new,cbufl.value:=maxNameLength,
  let dsize = CIntHolder.new,
  let prec = CShortHolder.new,
  let oscale = CShortHolder.new,
  let nullok = CShortHolder.new,
  
  (* execute odescr until call fails *)
  while(
    {oci.odescr(hstmt,columnCount+1,dbsize.handle,dbtype.handle,cbuf.handle,
                cbufl.handle,dsize.handle,prec.handle,oscale.handle,
		nullok.handle) = 0},
    {
      columnCount:=columnCount+1,
      let stringSize = cbufl.value > maxNameLength ? {maxNameLength}
                                                   : {cbufl.value},
      let str = MutableString.new(stringSize),
      for(0,stringSize-1,fun (i:Int) {str[i]:=cbuf.value[i]}),
      columnNames.addLast(str),
      nulls.addLast( nullok.value != 0 ),
      dbtype.value = oci.VARCHAR
        ? {precisions.addLast(dsize.value)} :{
      dbtype.value = oci.DATE
        ? {precisions.addLast(19)} (* DATE *)
        : {precisions.addLast(prec.value)}},
      scales.addLast(oscale.value),
      types.addLast(dbtype.value),
      cbufl.value:=100
    }
  ),
  dbsize.close,dbtype.close,cbuf.close,cbufl.close,
  dsize.close,prec.close,oscale.close,nullok.close,
  let error = OCIError.new(hdbc,hstmt),
  error.errorCode != oci.COLUMN_NOT_FOUND ? {error.raise},
    (* error COLUMN_NOT_FOUND is raised by Oracle
       if no further columns exist *)
  (* create the metaData-arrays and copy the data from the GapArrays *)
  _columnCount:=columnCount,
  _columnNames:=MutableArray.new(_columnCount),
  _nulls:=MutableArray.new(_columnCount),
  _precisions:=MutableArray.new(_columnCount),
  _scales:=MutableArray.new(_columnCount),
  _types:=MutableArray.new(_columnCount),
  for(0,_columnCount-1,fun (i:Int)
    {
      _columnNames[i]:=columnNames[i],
      _nulls[i]:=nulls[i],
      _precisions[i]:=precisions[i],
      _scales[i]:=scales[i],
      _types[i]:=types[i]
    })
}


;







