(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *

Cursor produced bei OCIStatement

Author:  Michael Skusa

Date:    04-Sep-1996

Updates: (Date)		(Name)	(Description)
	 14-mar-1997	MS	replaced integers for return-, type- and
				error-codes with named constants
*)

class OCICursor

super SQLCursor

metaclass SimpleConcreteClass(OCICursor)

public

hdbc:Int32

methods

close:Void
{
  super.close,
  for(0,_indp.size-1,fun(i:Int)
    {
      _indp[i].close,
      _rcode[i].close
    })
}

next:Bool
   (* fetches the next result row from the database,
      answers true on success,
              false if no further data was found
    *)
{
  _hstmt.isNotNil ?
  {
  oci.ofen(_hstmt,1) = 0 ? {true}
                         : {let error = OCIError.new(hdbc,_hstmt),
			     ((error.errorCode = oci.NO_MORE_ROWS)
			   || {error.errorCode = oci.FETCH_OUT_OF_SEQUENCE})
			   ? {false}
			                                                         : {error.raise}}}
  (*
     no more rows (first unsuccesful fetch),
     fetch out of sequence (further unsuccessful fetches)
  *)
  : {let n:Bool = nil}
}

private

_hstmt:Int32,

_indp:MutableArray(CShortHolder),

_rcode:MutableArray(CShortHolder)

methods

_createCursorMetaData(hstmt:Int32):OCICursorMetaData
{
  let m = OCICursorMetaData.new(),
  m.hdbc:=hdbc,
  m.retrieveColumnData(hstmt),
  m
}

_allocateDataArea:Void
{
  _dataArea:=MutableArray.new(metaData.columnCount),
  for (0,_dataArea.size-1,fun (i:Int)
    {
      let t = metaData.sqlType(i),
      (t=oci.NUMBER)
      ? { ((metaData.scale(i) = 0) && {metaData.precision(i) <= 8})
          ? {_dataArea[i]:=CIntHolder.new}
	  : {_dataArea[i]:=CRealHolder.new}
	} : {
      (t=oci.LONGRAW)
      ? {_dataArea[i]:=CRawStringHolder.new(oci.maxRawBuffer)}
      : {_dataArea[i]:=CStringHolder.new(metaData.precision(i))}}
    })

}

_allocateInfoDataArea():Void
{
  _lengthDataArea:=MutableArray.new(metaData.columnCount),
  _indp:=MutableArray.new(metaData.columnCount),
  _rcode:=MutableArray.new(metaData.columnCount),
  for (0,_lengthDataArea.size-1,fun (i:Int)
    {
	_lengthDataArea[i]:=CShortHolder.new,
	_indp[i]:=CShortHolder.new,
	_rcode[i]:=CShortHolder.new,
	_rcode[i].setShortValue(oci.RETURNED_NULL) (* inital value of
	                                              column is nil *)
    })
}

_bindColumns():Void
{
  for(0,metaData.columnCount()-1, fun (i:Int)
    {
      let t = metaData.sqlType(i),
      let bufl =
        (t = oci.NUMBER)
	? { ((metaData.scale(i) = 0) && {metaData.precision(i) <= 8})
	    ? {4} (* Int *)
	    : {8} (* Real *)
	  } :{
	(t = oci.LONGRAW) ? { oci.maxRawBuffer }         (* Binary data *) 
                          : {metaData.precision(i)+1} }, (* NTS *)
      let ftype =
        (t = oci.NUMBER)
	? { ((metaData.scale(i) = 0) && {metaData.precision(i) <= 8})
	    ? {oci.fTypeCode[Int]}
	    : {oci.fTypeCode[Real]}
	  } :{
	(t = oci.LONGRAW) ? {oci.fTypeCode[File]}
                          : {oci.fTypeCode[String]}},
      oci.odefin(_hstmt,i+1,_dataArea[i].handle,bufl,ftype,-1,
                 _indp[i].handle,"",-1,-1,_lengthDataArea[i].handle,
		 _rcode[i].handle) != 0
      ? {OCIError.new(hdbc,_hstmt).raise}
     })
}

_unbindColumns():Void
{
  nil
}

_isNull(column:Int):Bool
{
  _rcode[column].value = oci.RETURNED_NULL
}

_isDate(column:Int):Bool
{
  metaData.sqlType(column) = oci.DATE
}

_isBlob(column:Int):Bool
{
  metaData.sqlType(column) = oci.LONGRAW
}

_formatDate(column:Int):Date
{
  _isDate(column)
    ? {Date.fromString(_dataArea[column].stringValue,"%Y-%m-%d %H:%M:%S")}
    : {CoerceError.new(_dataArea[column].stringValue,Date).raise}
}

_retrieveRaw(column:Int, outputFile:File):File
{
  outputFile.openWrite,
  let var offset = 0,
  let currentLength = CIntHolder.new,
  oci.oflng(_hstmt,column+1,_dataArea[column].handle,oci.maxRawBuffer,
            oci.fTypeCode[File],currentLength.handle,offset) != 0
    ? {
        currentLength.close,
	OCIError.new(hdbc,_hstmt).raise
      },
  while({!(currentLength.value < oci.maxRawBuffer)}, {
    let data = _dataArea[column].rawStringValue,
    outputFile.writeBuffer(data,0,oci.maxRawBuffer),
    offset := offset+oci.maxRawBuffer,
    oci.oflng(_hstmt,column+1,_dataArea[column].handle,oci.maxRawBuffer,
              oci.fTypeCode[File],currentLength.handle,offset) != 0
      ? {
          currentLength.close,
	  OCIError.new(hdbc,_hstmt).raise}
	}
  ),
  let data = _dataArea[column].rawStringValue,
  outputFile.writeBuffer(data,0,currentLength.value),
  outputFile.close,
  currentLength.close,
  outputFile
}

;










