(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *

Cursor produced bei SQLStatement

Author:  Michael Skusa

Date:    16-Aug-1996

Updates: (Date)		(Name)	(Description)

         11-Mar-1997	MS	modified getObjects-method, for binary data
				the string "*** Binary Large Object ***" is
				returned. The binary data can be retrieved
				using the getRaw-method.
           
				replaced integer values for return codes,
				SQL-types and ODBC-standard-parameters with
				integer-constants defined in class ODBC.

	 4-Apr-1997	MS	Tycoons locale has to be C or POSIX.
	                        Otherwise next() fails if cursor
				contains TIMESTAMP-data.
*)

class ODBCCursor

super SQLCursor

metaclass SimpleConcreteClass(ODBCCursor)

public methods

next():Bool
   (* fetches the next result row from the database,
      answers true on success,
              false if no further data was found
      note: - Because of a bug in the ADABAS-ODBC-Driver
              next sometimes fails while "fetching" Real-values
	      -> Bus Error
    *)
{
  _hstmt.isNotNil ?
  {
  
  let error = odbc.SQLFetch(_hstmt),
  ((error = odbc.SQL_SUCCESS) || {error = odbc.SQL_SUCCESS_WITH_INFO})
  ? {true}
  : {error = odbc.SQL_NO_DATA_FOUND
     ? {false}
     : {ODBCError.new(odbc.NULL,odbc.NULL,_hstmt).raise}}
  }
  : {let n:Bool = nil}
}

private

_hstmt:Int32,

_dataArea:MutableArray(AnyCValueHolder)

methods

_createCursorMetaData(hstmt:Int32):ODBCCursorMetaData
{
  let m = ODBCCursorMetaData.new(),
  m.retrieveColumnData(hstmt),
  m
}

_allocateDataArea:Void
{
  _dataArea:=MutableArray.new(metaData.columnCount),
  for (0,_dataArea.size-1,fun (i:Int)
    {
      let t = metaData.sqlType(i),
      ((t>=odbc.SQL_NUMERIC) && {t<=odbc.SQL_SMALLINT})
      ? { ((metaData.scale(i) = 0) & (metaData.precision(i) <=8))
          ? {_dataArea[i]:=CIntHolder.new}
	  : {_dataArea[i]:=CRealHolder.new}
	} :{
      ((t>=odbc.SQL_FLOAT) && {t<=odbc.SQL_DOUBLE})
      ? {_dataArea[i]:=CRealHolder.new} : {
      (t=odbc.SQL_TIMESTAMP)
      ? {_dataArea[i]:=CStringHolder.new(  metaData.precision(i)
                                         + metaData.scale(i)
					 + 1) } :{
      ((t= odbc.SQL_LONGVARCHAR) || {t= odbc.SQL_LONGVARBINARY})
      ? {_dataArea[i]:=CRawStringHolder.new(odbc.rawBufferLength)}
      : {_dataArea[i]:=CStringHolder.new(metaData.precision(i))}}}}
    })
}
    
_allocateInfoDataArea():Void
{
  _lengthDataArea:=MutableArray.new(metaData.columnCount),
  for (0,metaData.columnCount()-1,fun (i:Int)
    {
	_lengthDataArea[i]:=CIntHolder.new,
	_lengthDataArea[i].setIntValue(odbc.SQL_NULL_DATA)
    })
}

_bindColumns():Void
{
  for(0,metaData.columnCount-1, fun (i:Int)
    {
      let t = metaData.sqlType(i),
      let maxlength = ((t>=odbc.SQL_NUMERIC) && {t<=odbc.SQL_DOUBLE})
                        ? {0} (* numerical types *)
		        : {
		      (t=odbc.SQL_TIMESTAMP)  
		        ? {metaData.precision(i)+metaData.scale(i)+2} :{
		      ((t=odbc.SQL_LONGVARCHAR) || {t=odbc.SQL_LONGVARBINARY}) 
		        ? {odbc.rawBufferLength}      (* Raw *)
		        : {metaData.precision(i)+1} (* String *)
		      }},
      let CType = ((t>=odbc.SQL_NUMERIC) && {t<=odbc.SQL_SMALLINT})
                  ? { ((metaData.scale(i) = 0) && {metaData.precision(i) <=8})
                      ? {odbc.CTypeCode[Int]}
		      : {odbc.CTypeCode[Real]}
		    } :{
		  ((t>=odbc.SQL_FLOAT) && {t<=odbc.SQL_DOUBLE})
		  ? {odbc.CTypeCode[Real]} :{
		  ((t=odbc.SQL_LONGVARCHAR) || {t=odbc.SQL_LONGVARBINARY})
		  ? {odbc.CTypeCode[File]}
		  : {odbc.CTypeCode[String]}}},
      let error = (odbc.SQLBindCol(_hstmt,i+1,CType,_dataArea[i].handle,
                                   maxlength,_lengthDataArea[i].handle) != 0),
      error ? { let er = ODBCError.new(odbc.NULL,odbc.NULL,_hstmt),
                self.close(),
		er.raise }
     })
}

_unbindColumns():Void
{
  odbc.SQLFreeStmt(_hstmt,odbc.SQL_UNBIND)
}

_isNull(column:Int):Bool
{
  _lengthDataArea[column].value = odbc.SQL_NULL_DATA
}

_isDate(column:Int):Bool
{
     (metaData.sqlType(column) >= odbc.SQL_DATE)
  && {metaData.sqlType(column) <= odbc.SQL_TIMESTAMP}
}

_isBlob(column:Int):Bool
{
     (metaData.sqlType(column) = odbc.SQL_LONGVARCHAR)
  || {metaData.sqlType(column) = odbc.SQL_LONGVARBINARY}
}

_formatDate(column:Int):Date
{
  metaData.sqlType(column) = odbc.SQL_DATE
    ? {Date.fromString(_dataArea[column].stringValue,"%Y-%m-%d")}
    : {
  metaData.sqlType(column) = odbc.SQL_TIME
    ? {Date.fromString(_dataArea[column].stringValue,"%H:%M:%S")}
    : {
  metaData.sqlType(column) = odbc.SQL_TIMESTAMP
    ? {Date.fromString(_dataArea[column].stringValue,"%Y-%m-%d %H:%M:%S")}
    : {
  CoerceError.new(_dataArea[column].stringValue,Date).raise }}}
}

_retrieveRaw(column:Int, outputFile:File):File
{
  outputFile.openWrite,
  let var sqlError = ODBCError.new(odbc.NULL,odbc.NULL,_hstmt),
  while({sqlError.isDataTruncated}, 
  {
    let data = _dataArea[column].rawStringValue,
    outputFile.writeBuffer(data,0,odbc.rawBufferLength),
    odbc.SQLGetData(_hstmt,column+1,odbc.CTypeCode[File],
                    _dataArea[column].handle,odbc.rawBufferLength,
		    _lengthDataArea[column].handle),
    sqlError := ODBCError.new(odbc.NULL,odbc.NULL,_hstmt)
  }),
  outputFile.writeBuffer(_dataArea[column].rawStringValue,0,
                         _lengthDataArea[column].intValue),
  outputFile.close,
  sqlError.errorCode == 0
  ? {outputFile}
  : {sqlError.raise}
}

;










