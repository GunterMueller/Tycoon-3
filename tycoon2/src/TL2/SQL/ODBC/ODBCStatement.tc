(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *

SQL-Statement produced by ODBCConnection

Author:  Michael Skusa

Date:    27-Aug-1996

Updates: (Date)		(Name)	(Description)
	 4-Apr-1997	MS      Tycoons locale has to be C or POSIX.
	                        Otherwise _execute fails if statement
				contains TIMESTAMP-parameters.
*)

class ODBCStatement

super SQLStatement

metaclass SimpleConcreteClass(ODBCStatement)

public methods

cancel():Void
  (* Closes cursor,
     cancels odbc-cursor,
     raises ODBCError.
   *)
{
  _cursor.isNotNil ?
  {
    (odbc.SQLFreeStmt(_hstmt,odbc.SQL_CLOSE) = odbc.SQL_SUCCESS)
    ? {_cursor.close}
    : {ODBCError.new(odbc.NULL,odbc.NULL,_hstmt).raise}
  }
}

getUpdateCount():Int
  (* returns the number of rows affected by execute,
     returns nil if _hstmt is nil
   *)
{
  _hstmt.isNotNil ?
  {
  let n = CIntHolder.new(),
  (odbc.SQLRowCount(_hstmt,n.handle) = 0)
  ? {let count=n.value,
     n.close(),
     count}
  : {n.close(),
     ODBCError.new(odbc.NULL,odbc.NULL,_hstmt).raise}
  }
  : {let n:Int = nil}
}

setInt(parameterIndex:Int, value:Int):Int
{
  value.isNil
  ? {_parameterLengthDataArea[parameterIndex].setIntValue(odbc.SQL_NULL_DATA)}
  : {
      _parameterDataArea[parameterIndex].setIntValue(value),
      _parameterLengthDataArea[parameterIndex].setIntValue(0)
    },
  value
}

setReal(parameterIndex:Int, value:Real):Real
{
  value.isNil
  ? {_parameterLengthDataArea[parameterIndex].setIntValue(odbc.SQL_NULL_DATA)}
  : {
      _parameterDataArea[parameterIndex].setRealValue(value),
      _parameterLengthDataArea[parameterIndex].setIntValue(0)
    },
  value
}

setString(parameterIndex:Int, value:String):String
{
  value.isNil
  ? {_parameterLengthDataArea[parameterIndex].setIntValue(odbc.SQL_NULL_DATA)}
  : {
      _parameterDataArea[parameterIndex].setStringValue(value),
      _parameterLengthDataArea[parameterIndex].setIntValue(odbc.SQL_NTS)
    },
  value
}

setDate(parameterIndex:Int, value:Date):Date
{
  value.isNil
  ? {_parameterLengthDataArea[parameterIndex].setIntValue(odbc.SQL_NULL_DATA)}
  : {
      let type = parameterMetaData.getSqlType(parameterIndex),
      let dbValue =
        type = odbc.SQL_DATE
          ? {value.format("%Y-%m-%d")} :{
	type = odbc.SQL_TIME
	  ? {value.format("%H:%M:%S")} :{
	type = odbc.SQL_TIMESTAMP
	  ? {value.format("%Y-%m-%d %H:%M:%S.000000")}
	  : {""}}},
      _parameterDataArea[parameterIndex].setStringValue(dbValue),
      _parameterLengthDataArea[parameterIndex].setIntValue(odbc.SQL_NTS)
   },
  value 
}

setRaw(parameterIndex:Int, value:File):File
{
  value.isNil
  ? {_parameterLengthDataArea[parameterIndex].setIntValue(odbc.SQL_NULL_DATA)}
  : {
     _rawData[parameterIndex]:=value,
       (* inserts the RAW-data-file into a private dictionary. *) 
     _parameterLengthDataArea[parameterIndex].setIntValue(odbc.SQL_DATA_AT_EXEC)},
       (* this indicates, that the RAW-data will be inserted AFTER *)
       (* SQLExec has been called                                  *)
  value
}

private

_rawData:Dictionary(Int,File)

methods

_open(hdbc:Int32):Void
{
  let h=CIntHolder.new(),
  (odbc.SQLAllocStmt(hdbc,h.handle) = odbc.SQL_SUCCESS)
  ? {_hstmt := h.value32,h.close}
  : {
     h.close,
     ODBCError.new(odbc.NULL,hdbc,odbc.NULL).raise
    }
}

_createParameterMetaData(hstmt:Int32):ODBCParameterMetaData
{
  let m = ODBCParameterMetaData.new(),
  m.retrieveParameterMetaData(hstmt),
  m
}

_allocateParameterDataArea:Void
{
  _parameterDataArea:=MutableArray.new(parameterMetaData.getParameterCount),
  for (0,_parameterDataArea.size-1,fun (i:Int)
    {
      _parameterClasses[i] = Int
      ? {_parameterDataArea[i]:=CIntHolder.new} :{
      _parameterClasses[i] = Real
      ? {_parameterDataArea[i]:=CRealHolder.new} :{
      _parameterClasses[i] = String
      ? {setMaxLength(i,parameterMetaData.getPrecision(i)),
         _parameterDataArea[i]:= CStringHolder.new(_parameterMaxLength[i])} :{
      _parameterClasses[i] = Date
      ? {setMaxLength(i,parameterMetaData.getPrecision(i) + parameterMetaData.getScale(i) + 1),
         _parameterDataArea[i]:= CStringHolder.new(_parameterMaxLength[i])} :{
      _parameterClasses[i] = File
      ? {setMaxLength(i,0),
         _parameterDataArea[i]:= CRawStringHolder.new(_parameterMaxLength[i])}
	   (* dummy-buffer. Data is passed via separate *)
	   (* buffers at statement-execution-time.      *)
      : {CoerceError.new("class not supported",_parameterClasses[i]).raise}}}}}
    })
}

_allocateParameterLengthDataArea()
{
  _parameterLengthDataArea:=
    MutableArray.new(parameterMetaData.getParameterCount),
  for (0,parameterMetaData.getParameterCount-1,fun (i:Int)
    {
	_parameterLengthDataArea[i]:=CIntHolder.new(),
	_parameterLengthDataArea[i].setIntValue(odbc.SQL_NULL_DATA)
    })
}

_bindParameters:Void
{  
  for(0,parameterMetaData.getParameterCount-1, fun (i:Int)
    {
      let dataHandle = _parameterClasses[i]=File
      ? {i.asInt32}
      : {_parameterDataArea[i].handle},
        (* For normal parameters the dataHandle is a handle for the      *)
	(* buffer in which the parameter values are stored.              *)
	(* For RAW-parameters the dataHandle is an application-defined   *)
	(* pointer or number which is returned by SQLParamData at        *)
	(* execution time. In this implementation the value for RAW-data *)
	(* is the internal parameter-index, which is used by             *)
	(* _putRawParameters.                                            *)
	
      let error = (odbc.SQLBindParameter(_hstmt,i+1,1,
                     odbc.CTypeCode[_parameterClasses[i]],
		     parameterMetaData.getSqlType(i),
		     parameterMetaData.getPrecision(i),
		     parameterMetaData.getScale(i),
		     dataHandle,
		     _parameterMaxLength[i]+1,
		     _parameterLengthDataArea[i].handle) != odbc.SQL_SUCCESS),
      error ? { let er = ODBCError.new(odbc.NULL,odbc.NULL,_hstmt),
                _freeParameterAreas(),
		er.raise }
     })
}

_nativeParameter(name:String):String { "?" }

_dropStatement()
{
  odbc.SQLFreeStmt(_hstmt,odbc.SQL_DROP)
}

_prepare(sql:String):Void
{ 
  (odbc.SQLPrepare(_hstmt,sql,odbc.SQL_NTS) != odbc.SQL_SUCCESS)
  ? {ODBCError.new(odbc.NULL,odbc.NULL,_hstmt).raise}
}

_putRawParameters():Void
{
  let var error = odbc.SQL_NEED_DATA,
  let cBuffer = CRawStringHolder.new(odbc.rawBufferLength),
  let pNumberBuffer = CIntHolder.new,
  let stringBuffer = MutableString.new(odbc.rawBufferLength),
  while({error = odbc.SQL_NEED_DATA},{

    error := odbc.SQLParamData(_hstmt,pNumberBuffer.handle),
      (* retrieve parameter index of next RAW-Parameter,                *)
      (* SQLParamData returns odbc.SQL_NEED_DATA if a RAW-parameter was *)
      (* found, its index is stored in pNumberBuffer.                   *)
      (* The value of pNumberBuffer was defined by _bindParameters.     *)
      (* If no further RAW-parameter exists, SQLParamData returns 0     *)

    error = odbc.SQL_NEED_DATA
     ? {
         (* open the file, containing the RAW-data and transfer its          *)
	 (* contents in pieces of size odbc.rawBufferLength to the database. *)
	 let var length = odbc.rawBufferLength,
	 _rawData.includesKey(pNumberBuffer.intValue)
	 ? {
	     (* Parameter was set by setRaw *)
             let currentFile = _rawData[pNumberBuffer.intValue].openRead,
	     let var length = odbc.rawBufferLength,
	     until({length < odbc.rawBufferLength}, fun() {
	       length:=
	       currentFile.readBuffer(stringBuffer,0,odbc.rawBufferLength),
	       cBuffer.setRawStringValue(stringBuffer),
	       odbc.SQLPutData(_hstmt,cBuffer.handle,length) != odbc.SQL_SUCCESS
	       ? {
		   cBuffer.close,
		   pNumberBuffer.close,
		   ODBCError.new(odbc.NULL,odbc.NULL,_hstmt).raise
	         }
	      }), 
	      currentFile.close
	    }
	: {  (* Parameter was not set -> insert NULL-Value into DB *)
	     length := odbc.SQL_NULL_DATA,
	     odbc.SQLPutData(_hstmt,cBuffer.handle,length) != odbc.SQL_SUCCESS
	     ? { cBuffer.close,
		 pNumberBuffer.close,
		 ODBCError.new(odbc.NULL,odbc.NULL,_hstmt).raise
	       }
	   }  
	}
      : { error != odbc.SQL_SUCCESS
          ? {cBuffer.close, pNumberBuffer.close,
	     ODBCError.new(odbc.NULL,odbc.NULL,_hstmt).raise}
	}
  }),
  cBuffer.close,
  pNumberBuffer.close
}

_execute():Void
{
  _hstmt.isNotNil ?
  {
    let error = odbc.SQLExecute(_hstmt),
    error != odbc.SQL_SUCCESS
    ? { error = odbc.SQL_NEED_DATA
          ? { _putRawParameters }
          : {ODBCError.new(odbc.NULL,odbc.NULL,_hstmt).raise}
      }
   }
}

_executeDirect(sql:String):Void
{
   _hstmt.isNotNil ?
   {
     (odbc.SQLExecDirect(_hstmt,sql,odbc.SQL_NTS) != odbc.SQL_SUCCESS)
     ? {ODBCError.new(odbc.NULL,odbc.NULL,_hstmt).raise}
   }
}

_unbindParameters():Void
{
  odbc.SQLFreeStmt(_hstmt,odbc.SQL_RESET_PARAMS)
}

_createCursor(_hstmt:Int32):ODBCCursor
{
  let c = ODBCCursor.new,
  c.open(_hstmt),
  c
}

_init:Self
{
   super._init,
   _rawData:=Dictionary.new,
   self
}

;



