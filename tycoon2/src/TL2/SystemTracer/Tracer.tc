class Tracer
super SystemTracer
metaclass SimpleConcreteClass(Tracer)
public

formatAction :Dictionary(Char, Fun1(Object, Void)),

oids :IdDictionary(Object, Int),

agenda :Queue(MemBlock),

allocOid :Int,
writePtr :Int,   (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 for consistency checking *)

out :Output,

classToTL2Class :Dictionary(Class, Pair(TL2Class, TspDescriptor)),

verbose :Bool,

root :TL2Root,

currentHistory :List(Object),

identification :Cell(Object)   (* needed by StructDescriptor *)

methods

trace(root :TL2Root, on :Output)
{ (* collectSymbols(root), *)
  (* root.symbolTable := tycoon.tl.root.symbolTable.as(Set), *)
  trace1(root, root, on)
}

collectSymbols(root :TL2Root)
{
  let progress =
    ProgressIndicator.new("Collecting symbols (this will take about 2 minutes)", tycoon.tl.root.symbolTable.size),
  root.symbolTable := nil,
  let visited = IdSet(:Object).new,
  let symbols = Set(:Symbol).new,
  let agenda = Queue(:Object).new,
  let class2iterateOIDs = Dictionary(:Class, :Fun2(Object, Fun1(Object,Void), Void)).new,
  let nop = fun(:Object, :Fun1(Object,Void)) :Void { },
  let iterateArray =
    fun(o :Object, visit :Fun1(Object, Void)) :Void {
      for(0,o.__basicSize-1,fun(i:Int) {
        visit[o.__basicAt(i)]
      }) },
  let addIfNew =
    fun(o :Object) :Void {
      (* makes collectSymbols factor 1.5 faster than with includes + add *)
      let nVisited = visited.size,
      visited.add(o),
      visited.size > nVisited
      ? { agenda.addLast(o) }
    },
  let symbolClass = Symbol,

  agenda.add(root),
  (*
   let var i = 1,
   let var mark = 2,
   *)
  while({ !agenda.isEmpty }, {
    let o = agenda.removeFirst,
    let c = o."class",
    c == symbolClass
    ? { progress.click,
        symbols.add(_typeCast(o,:Symbol)) }
    : { let iterateOIDs =
	  class2iterateOIDs.memoize(c, {
	    let name =
	      c == TL2Class
	      ? { "Class" }
	      : { c == TL2Root
		  ? { "Root" }
		  : { c.name } },
	    let desc =
	      root.storeDescriptors.lookup(name,
		fun(d :TspDescriptor){ d },
		{ ArrayDescriptor.instance }),
	    let var iterateOIDs = nop,
	    let layout = desc.layout,
	    layout = desc.layoutArray
	    ? { iterateOIDs := iterateArray }
	    : { layout = desc.layoutStruct
		? { let format = desc.format,
		    let oidIndices =
		      format.keys.select(fun(i:Int){format[i]='o'}).as(Array),
		    !oidIndices.isEmpty
		    ? { iterateOIDs :=
			  fun(o :Object, visit :Fun1(Object, Void)) {
			    oidIndices.do(fun(i:Int) {
			      visit[o.__basicAt(i)]
			    })
			  } } } },
	    iterateOIDs }),
	iterateOIDs[o, addIfNew] }
    (* ,
    i := i + 1,
    i = mark ? {
      tycoon.stdout << i << '\t' << agenda.size << '\t' << symbols.size << '\n',
      mark := i + agenda.size
    } *)
  }),
  root.symbolTable := symbols,
  progress.finish,
  tycoon.stdout << "Found "<<symbols.size<<" symbols.\n",
  nil
}

trace1(root :TL2Root, o :Object, on :Output)
{
  oids := IdDictionary.new,
  out := on,
  agenda := Queue.new,
  self.root := root,
  allocOid := 1,
  currentHistory := EmptyList.new,
  let rootOID = getOID(o),
  assert rootOID = 1*4,
  let var dots = 0,
  while({!agenda.isEmpty (*&&{ agenda[0].oid < 10000 }*)},{
    (dots % 10) = 0 ? { tycoon.stdout.write('.') },
    dots := dots + 1,
    dots = 100
    ? { dots := 0,
	let std = tycoon.stdout,
        std.tab,
	let oid = agenda[0].oid,
	oid.print,
	std.tab,
	allocOid.print,
	std.tab,
	(allocOid - oid).print,
        std.nl },
    handleAgenda
  }),
  writeUInt(root.nextClassId),
  writeUInt(allocOid-1)
}

traceToFile(root :TL2Root, path :String)
{
  let f = BufferedOutput.new(File.openWrite(path), 8192),
  try({
    trace(root, f), "ok!".print
  }, fun(e:Exception){
    f.close, e.raise
  }),
  f.close,
  true
}

handleAgenda
{
  let block = agenda.removeFirst,
  currentHistory := block.history,

  let out = tycoon.stdout,
  verbose ? {
    block.oid.printOn(out),   out.tab,
    block.size.printOn(out),   out.tab,
    block.hasch.printOn(out),   out.tab,
    out.writeString(root.classTable[block.classId].name), out.tab
  },
  
  writePtr := 0,
  writeUInt(block.size),
  writeUInt((block.hasch."<<"(12)) + block.classId),

  try({
    block.contents[]
  }, fun(e:Exception) {
    tycoon.stdout << "Exception, history: ",
    showHistory,
    tycoon.stdout.nl,
    e.raise
  }),

  assert writePtr = 8 + block.size,
  wrAlign(4),
  verbose ? { out.nl }
}

showHistory
{
  currentHistory.do(fun(o:Object) {
    o."class".name.print, tycoon.stdout.nl
  })
}

dumpOID(o :Object)
{ writeUInt(getOID(o))
}

dumpC(o :Object, format :Char)
{ (*wrAlign(_alignment[format]),*)
  formatAction[format][o]
}

(* short for multiple calls to dumpC with format C *)
dumpAllC_C(str :String)
{ writePtr := writePtr + str.size,
  out.writeString(str)
}

alignment(format :Char) :Int
{ _alignment[format] }

sizeof(format :Char) :Int
{ _sizeof[format] }

getOID(o :Object) :Int
{ o.isNil
  ? { 0 }
  : { oids.memoize(o, {
        o."class" = Int
	 ? { let i = _typeCast(o, :Int),
	     i * 4 + 1 }
	 : { allocateOid(o) }
      }) }
}

allocateOid(o :Object) :Int
{
  let classDescr =
    classToTL2Class.memoize(o."class", {
      (* In the OLD system, Class::name is an uninterned symbol with wrong hash value,
         so we have to convert it to String *)
      let clazz = o."class",
      let name =
        clazz == TL2Class
	? { "Class" }
	: { clazz == TL2Root
	    ? { "Root" }
	    : { String.fromSequence(clazz.name) } },
      let tl2Class = root.classes.detect(fun(c:TL2Class){ c.name = name }),
      tl2Class.isNil
      ? { tycoon.stdout.writeln("Unknown class "+name),
          assert false },
      tycoon.stdout.writeString(name+": "), showHistory,
      let desc =  (* tl2Class.storeDescriptor  --- no reference to classManager during bootstrap! *)
        root.storeDescriptors.lookup(name,
	  fun(d :TspDescriptor){ d },
          { ArrayDescriptor.instance }),
      Pair.new(tl2Class, desc)
    }),
  let tl2Class = classDescr.first,
  let descr = classDescr.second,
  descr.allocate(o, tl2Class, self)
}

(* return an OID for <bytes> bytes of memory with classId <classId>.
   <contents> will be called later and calls back to dumpOID / dumpC
   to produce the desired contents. *)
allocate(o :Object, bytes :Int, classId :Int, hash :Int, contents :Fun0(Void)) :Int
{
  let block = MemBlock.new,
  block.oid := allocOid,
  block.size := bytes,
  block.hasch := hash & 16383,
  block.classId := classId,
  block.contents := contents,
  block.history := List.cons(o, currentHistory),

  allocOid := allocOid + 1,
  agenda.addLast(block),
  verbose ? { block.oid.print, tycoon.stdout.write(' ') },
  block.oid * 4
}

align(i :Int, n :Int) :Int
{ (* round up *)
  (i + n - 1) / n * n
}

private

_alignment :Dictionary(Char, Int),
_sizeof :Dictionary(Char, Int),
_buffer :MutableString

methods

fmtChar(c :Char, align :Int, sizeof :Int, action :Fun1(Object, Void))
{
  formatAction[c] := action,
  _alignment[c] := align,
  _sizeof[c] := sizeof
}

_init :Void
{ super._init,
  identification := Cell(:Object).new(nil),

  verbose := false,
  formatAction := Dictionary.new,
  _alignment := Dictionary.new,
  _sizeof := Dictionary.new,
  _buffer := MutableString.new(8),

  fmtChar('o', 4, 4, fun(o :Object){ dumpOID(o) }),
  fmtChar('c', 1, 1, fun(o :Object){ writeChar(toInt(o)) }),
  fmtChar('C', 1, 1, fun(o :Object){ writeUChar(toInt(o)) }),
  fmtChar('s', 2, 2, fun(o :Object){ writeShort(toInt(o)) }),
  fmtChar('S', 2, 2, fun(o :Object){ writeUShort(toInt(o)) }),
  fmtChar('i', 4, 4, fun(o :Object){ writeInt(toInt(o)) }),
  fmtChar('I', 4, 4, fun(o :Object){ writeUInt(toInt(o)) }),
  fmtChar('d', 8, 8, fun(o :Object){ writeDouble(toDouble(o)) }),
  fmtChar('w', 8, 8, fun(o :Object){ writeLong(toLong(o)) }),   (* LongLong ? *)
  (* ### missing: l = Long, L = ULong, f = Float *)
  (* ### alignment for Double and Long is 4 on i386 *)

  classToTL2Class := Dictionary.new,
  
  self
}

toInt(o :Object) :Int
{
  let clazz = o."class",
  clazz == Int
  ? { _typeCast(o, :Int) }
  : { clazz == True || { clazz == False }
      ? { let b = _typeCast(o, :Bool),
	  b ? { 1 } : { 0 } }
      : { clazz == Char
	  ? { let c = _typeCast(o, :Char),
	      c.asInt }
	  : { clazz == self."Nil"
	    ? { 0 }
	    : { tycoon.stdout.writeString("can\'t convert to binary: "),
	        o.print,
	        assert false,
	        nil }}}}
}

toDouble(o :Object) :Real
{ o."class" == Real
  ? { _typeCast(o, :Real) }
  : { tycoon.stdout.writeString("not a double: "),
      o.print,
      assert false,
      nil }
}

toLong(o :Object) :Long
{ o."class" == Long
  ? { _typeCast(o, :Long) }
  : { tycoon.stdout.writeString("not a Long: "),
      o.print,
      assert false,
      nil }
}

wrB(i :Int)
{ (*assert 0 <= i & i <= 255,*)
  out.write(i.asChar),
  writePtr := writePtr + 1
}

wrAlign(n :Int)
{ n != 1 ? {
    let aligned = align(writePtr, n),
    while ({writePtr < aligned},{
      wrB(0)
    })
  }
}

writeChar(i :Int)
{
  assert -128 <= i & i <= 127,
  (* wrAlign(1), *)
  wrB(i & 255)
}

writeUChar(i :Int)
{
  assert 0 <= i & i <= 255,
  (* wrAlign(1), *)
  wrB(i)
}

writeShort(i :Int)
{
  assert -32768 <= i & i <= 32767,
  tycoon.tycoonOS.memory_pokeBufferShort(_buffer, 0, i),
  wrAlign(2),
  out.writeBuffer(_buffer, 0, 2),
  writePtr := writePtr + 2
}

writeUShort(i :Int)
{
  assert 0 <= i & i <= 65535,
  tycoon.tycoonOS.memory_pokeBufferShort(_buffer, 0, i),
  wrAlign(2),
  out.writeBuffer(_buffer, 0, 2),
  writePtr := writePtr + 2
}

writeInt(i :Int)
{
  (* assert ??? *)
  tycoon.tycoonOS.memory_pokeBufferInt(_buffer, 0, i),
  wrAlign(4),
  out.writeBuffer(_buffer, 0, 4),
  writePtr := writePtr + 4
}

writeUInt(i :Int)
{
  (* assert 0 <= i,  (* & ? *) *)  (* need to allow negative OIDs for negative numbers *)
  (*tycoon.stdout.writeString("["+writePtr.printString+":"+i.printString+"]"),*)

  (writePtr & 3) != 0 ? {   (* ### speed hack *)
    wrAlign(4)
  },
  tycoon.tycoonOS.memory_pokeBufferInt(_buffer, 0, i),
  out.writeBuffer(_buffer, 0, 4),
  writePtr := writePtr + 4
}

writeLong(l :Long)
{
  tycoon.tycoonOS.memory_pokeBufferLong(_buffer, 0, l),
  wrAlign(4),   (* ### 8 on Sparc *)
  out.writeBuffer(_buffer, 0, 8),
  writePtr := writePtr + 8
}

writeDouble(d :Real)
{ (*tycoon.stdout.writeln("\nA double! "+d.printString),*)
  tycoon.tycoonOS.memory_pokeBufferReal(_buffer, 0, d),
  wrAlign(4),  (* ### 8 on Sparc *)
  out.writeBuffer(_buffer, 0, 8),
  writePtr := writePtr + 8
}
;
