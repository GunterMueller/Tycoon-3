class MethodType 
  super TypeImpl, ApplyMixin
  metaclass MethodTypeClass
public 
  selector :Symbol,
  domain :List(Ide),
  range :Type

methods

  prettyPrint(out:Printer)
  {
    out.writeAll("Method "),
    selector.printOn(out),
    !domain.isEmpty ? {
      let var simpleDomain = domain.all(fun(i:Ide) {
			       i.type.isNil || {i.type.isLeaf}}),
      out.write('('),
      out.withAbsIndent(out.column, {
	domain.doBetween(fun(i :Ide) {
	  i.prettyPrint(out)
	}, {
	  out.write(','),
	  simpleDomain ? { out.space } : { out.nl }
	})
      }),
      out.write(')')
    },
    out.writeAll(" :"),
    range.isNil ? {
      out.writeAll("??")
    } : {
      range.prettyPrint(out)
    }
  }

  children :Reader(Value)
  {
    let r = domain.map(fun(i:Ide){i.type}),
    range.isNil
     ? { r }
     : { Reader.cons(range, r) }
  }

  scope(env :Scoper) :MethodType
  {
    env.withScopedSignatures(domain, {
      range.isNotNil ? { range := env.scope(range) }
    }),
    self
  }



  (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 visitor support
     calls the appropriate method in visitor
  *)
  visit(T <: Void, visitor :TypeVisitor(T)) :T
  {
    visitor.visitMethodType(self)
  }


  checkSubMethodType(big :MethodType, subst :Subst, bigSubst :Subst)
  {
    (* Sub Method:

       |- T <:: S   |- V[T/S] <: W
      -----------------------------
       |-   (S)->V  <:  (T)->W

       Principally, the same algorithm as for Sub Oper. A nice and hopefully sound implication:

       (T <: Void, :T) -> T    <:    (:String) -> String
    *)

    let bigArgs = List.fromReader(big.domain.map(fun(i :Ide) :Value {
      i.isTypeIde ? fun() :Value { let v :Value = IdeType.new(i.asTypeIde) } :
		    fun() :Value { let v :Value = IdeValue.new(i.asValueIde) }
    })),

    applyArgs(pos, domain, bigArgs, subst, bigSubst, range, true, false, true, fun(range :Type, subst :Subst) {
      range.checkSubType(big.range, subst, bigSubst)
    })
  }

;


  ;


