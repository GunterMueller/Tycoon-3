class VMInterfaceClass
super ConcreteClass(VMInterface)
metaclass MetaClass
public methods

new(builtinsPath :String,
    opcodesPath :String) :VMInterface
{
  let instance = _new,
  instance.builtins := parseBuiltins(builtinsPath),
  instance.opcodes := parseOpcodes(opcodesPath),
  instance._init
}

parseBuiltins(path :String) :Array(BuiltinDescriptor)
{
  let ga = GapArray.new0,
  parseTabs(path, 3, fun(a :Array(String)) {
    let className = a[0],
    let selector = a[1],
    let arity = a[2].asInt,
    ga.add(BuiltinDescriptor.new(ga.size, className,selector,arity))
  }),
  ga.asArray
}

parseOpcodes(path :String) :Dictionary(String, OpcodeDescriptor)
{
  let d = Dictionary.new,
  parseTabs(path, 3, fun(a :Array(String)) {
    let n = a[0].asInt,
    let mnemonic = a[1],
    let argBytes = a[2].asInt,
    d[mnemonic] := OpcodeDescriptor.new(n,mnemonic,argBytes)
  }),
  d
}

parseTabs(path :String, nFields :Int, fu :Fun1(Array(String),Void))
{
  let f = File.openRead(path).bufferedInput,
  let var line :String = nil,
  while({ line := f.readln, line.isNotNil }, {
    let t = Tokenizer.new(line.reader, "\t"),
    let a = Array.fromReader(t),
    a.size != nFields
    ? { tycoon.stdout << "Wrong number of fields in file "<<path<<": "
		      << "expected "<<nFields<<", found "<<a.size<<'\n',
	assert false },
    fu[a]
  }),
  f.close
}
;
