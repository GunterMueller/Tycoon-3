class Class_
super MutableClassState, ClassPublic
metaclass MetaClass_
(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 invariant
          no two slots with the same name
	  no two methods with the same name *)
public

id :Int, (* unique code for this class. Used to encode class information 
	    within object headers. *)

instanceSize :Int,
    (* size of instances in slots, used by the 'new' method.
       -> depends on _slotMap *)

cpl :ListSet(Class_),
    (* all superclasses in lookup order.
       This slot is maintained by the ClassManager. 
       -> depends on directSuperClasses and on their cpls. *)

methodDictionaries :List(MethodDictionaryPublic),
    (* contains all method dictionaries of the classes in CPL
       in lookup order. May also contain shadow method 
       dictionaries that hide slot methods with access
       and upate methods with the right indices (due 
       to multiple inheritance).
       This slot is maintained by the ClassManager.
       Used by TM during method lookup.
       -> depends on cpl, _slotMethods, methodDictionary,
       and on the _slotMethods and  methodDictionaries of
       all superclasses.. *)

cplTypes :List(CPLType),
    (* all superclasses in lookup order (Class Precedence List),
       used for typechecking. 
    *)

(* "<name> = <asType>"
   typeIde == TypeManager.instance.signature(name) *)
typeIde :TypeIde,

dependencies :Set(String),
    (* dependency list containing all global types (class names)
       and pool methods used within a class.
       Filled in during type checking.
    *)

classManager :ClassManager
    
methods

isSubClassOf(other :ClassPublic) :Bool
{ classManager.superclasses(self).includes(other) }

isSuperClassOf(other :ClassPublic) :Bool
{ (* slow, but safe *)
  classManager.subclasses(self).includes(other)
}

"metaclass" :ClassPublic
{ classManager."metaclass"(self) }

(* either an ObjectType or OperType, depending on whether domain is empty *)
asType :Type
{ typeIde.type }

setState(state :ClassState)
  require state.name == name
{
  super.setState(state),

  methodDictionary.setClass(self),

  (* ### gleich hier berechnen? *)
  (* cplTypes := nil, *)
  typeIde.type := nil,

  makeGenericSlotMethods
}

printOn(out:Output)
{
  out.writeString(name)
}

prettyPrint
{ prettyPrintOn(Printer.new(tycoon.stdout)) }

prettyPrintOn(out :Printer)
{
  pos.printOn(out), out.writeAll(":\n"),
  out.writeAll("class "+name),
  printSeperatedOn(domain, "(", ", ", ")\n", "\n", out),
  out.writeAll("super"),
  printSeperatedOn(supers, "\009", ",\n\009", "\n", " (* none *)\n", out),
  selfTypeSig.printOn(out),
  out.writeAll("\nmetaclass "),
  metaClassDeclaration.printOn(out),
  out.nl,
  printSeperatedOn(publicSlots, "public\n", ",\n", "\n", "public ", out),
  out.writeln("methods"),
  publicMethods.do(fun(m:Method) {
    m.prettyPrint(out),
    out.nl, out.nl
  }),
  printSeperatedOn(privateSlots, "private\n", ",\n", "\n", "private ", out),
  out.writeln("methods"),
  privateMethods.do(fun(m:Method) {
    m.prettyPrint(out),
    out.nl, out.nl
  }),
  out.writeln(";")
}

disassemble(vmInterface :VMInterface)
{
  let reader = ByteCodeReader.new(vmInterface, classManager.root),
  let out = Printer.new(tycoon.stdout),
  methodDictionary.do(fun(m :Method) {
    m.disassembleOn(out, reader)
  })
}

finalize
{
  methodDictionary.do(fun(m :Method) {
    m.finalize
  })
}

(* create a dictionary with slot access/update methods 
   for all my slots. Indices are fetched by calling
   slotPos with the name of the slot.  If no slot
   with that Id was asked for yet, slotPos returns a new position.
*)
makeSlotMethods(slotPos :Fun1(Symbol,Int)) 
		:MethodDictionary(SlotMethod)
{
  let dic = MethodDictionary.new1(_slotMethods.size),
  dic.setClass(self),
  _slotMethods.do(fun(m:SlotMethod) {
    dic.add(m.withOffset(slotPos[m.slotName]))
  }),
  dic
}

slotMethods :Sequence(SlotMethod)   (* DEBUG *)
{ _slotMethods }

slotMap :Array(Symbol)
{ _slotMap }

"slotMap:="(m :Array(Symbol))
  (* called by the classManager *)
{
  let newSize = m.size,
(*
  _slotMap.isNotNil ? {
    (* ### resize & remap existing objects in the store *)
    let log = tycoon.stdout,
    let shrink = newSize < instanceSize,
    let grow = newSize > instanceSize,
    grow ? {
      log.writeAll("grow from "),
      instanceSize.printOn(log),
      log.writeAll(" to "),
      newSize.printOn(log),
      log.nl
    },
    _slotMap.keysAndElementsDo(fun(index:Int, name:Symbol) {
      !m.includes(name) ? {
	log.writeString("removed slot "),
	name.printOn(log),
	log.writeString(" at "),
	index.printOn(log),
	log.nl
      }
    }),
    m.keysAndElementsDo(fun(newIndex:Int, name:Symbol) {
      let oldIndex = _slotMap.locate(name),
      oldIndex.isNil ? {
	log.writeString("added slot "),
	name.printOn(log),
	log.writeString(" at "),
	newIndex.printOn(log),
	log.nl
      } : {
	oldIndex != newIndex ? {
	  log.writeAll("moved slot "),
	  name.printOn(log),
	  log.writeAll(" from "),
	  oldIndex.printOn(log),
	  log.writeAll(" to "),
	  newIndex.printOn(log),
	  log.nl
	}
      }
    }),
    shrink ? {
      log.writeAll("shrink from "),
      instanceSize.printOn(log),
      log.writeAll(" to "),
      newSize.printOn(log),
      log.nl
    }
  },
  *)
  _slotMap := m,
  instanceSize := newSize
}

storeDescriptor :TspDescriptor
{
  classManager.root.storeDescriptors.lookup(name,
      fun(d :TspDescriptor){ d },
      { ArrayDescriptor.instance })
}

private

_slotMap :Array(Symbol),
_slotMethods :Sequence(SlotMethod)

methods

_init :Self
{
  super._init,
  methodDictionary.setClass(self),
  _slotMap := nil,
  _slotMethods := List.with0,
  instanceSize := 0,
  cpl := ListSet.new,
  typeIde := classManager.typeManager.newClassSignature(name),
  dependencies := Set.new,

  makeGenericSlotMethods,
  self
}    

publicMethods :Reader(Method)
{
  methodDictionary.select(fun(m:Method){!m.isPrivate})
}

privateMethods :Reader(Method)
{
  methodDictionary.select(fun(m:Method){m.isPrivate})
}

(* create a list of slot access/update methods for all slots of <class_> *)
makeGenericSlotMethods
{
  let nbSlots = publicSlots.size + privateSlots.size,
  let slotMethods = GapArray.new(nbSlots),
  makeGenericSlotMethods1(publicSlots, false, slotMethods),
  makeGenericSlotMethods1(privateSlots, true, slotMethods),
  _slotMethods := slotMethods
}

makeGenericSlotMethods1( slots :List(ValueIde), isPrivate :Bool,
		  bag :GapArray(SlotMethod))
{
  slots.do(fun(slot :ValueIde) {
    let sel = Symbol.new(slot.name),
    isStruct
    ? { bag.add( 
	  CSlotAccessMethod.new( slot.pos, sel, slot.type, isPrivate)),
	bag.add(
	  CSlotUpdateMethod.new( slot.pos, sel, slot.type, isPrivate)) }
    : { bag.add( 
	  SlotAccessMethod.new( slot.pos, sel, slot.type, isPrivate)),
	bag.add(
	  SlotUpdateMethod.new( slot.pos, sel, slot.type, isPrivate)) }
  })
}

isStruct :Bool
{ storeDescriptor.isStruct
}


printSeperatedOn( r :Container(Object), 
		  start :String, seperator :String, terminator :String,
		  ifEmpty :String,
		  out :Output)
{
  r.isEmpty ? {
    out.writeAll(ifEmpty)
  } : {
    out.writeAll(start),
    r.doBetween(fun(x :Object){ 
      x.printOn(out)
    }, { 
      out.writeAll(seperator)
    }),
    out.writeAll(terminator)
  }
}
;

