class ClassInstanceType 
  super ObjectType
  metaclass ClassInstanceTypeClass

public
  class_ :ClassPublic

methods

  visit(T <: Void, visitor :TypeVisitor(T)) :T { visitor.visitClassInstanceType(self) }
  	
  selfTypeSig :TypeIde { class_.selfTypeSig }


  (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 ## cache *)
  cpl :CPL 
  {
    CPL.new(_typeCast(class_))
  }

  prettyPrint(out :Printer)
  {
    out.writeAll(class_.name)
  }

  lookupWithSelf(T <: Void,
	 selector :Symbol,
	 subst :Subst,
	 withPrivate :Bool,
	 selfType :Type,
	 selfTypeSubst :Subst,
	 cont :Fun2(Method, Subst, T)) :T
  {
(*    tycoon.stdout.writeln("lookup "+class_.name+"::"+selector), *)
    let var method :Method = nil,
    
    let var md = class_.methodDictionaries,
    while({ method.isNil && { !md.isEmpty }}, {
      let dict = md.head,
      dict.includesKey(selector) ? {
        method := dict[selector],

	(* notify typeChecker *)
	dict == tycoon.tl.pool.poolMethods ? {
	  tycoon.tl.typeChecker.globalIdeReferenced(selector)
	},
	
	nil
      } : {
        md := md.tail,
	nil
      }
    }),

    method.isNil ? {
      raiseError
    },

    method.isPrivate && { !withPrivate } ? {
      raiseError
    },

    cont[method, CompositeSubst.new(
		   CompositeSubst.new(cplSubst, subst),
		   ConsSubst.new(class_.selfTypeSig,
				 SubstType.new(selfType, selfTypeSubst),
				 EmptySubst.instance
				 )
		 )]
  }

  methodsWithSelfDo(subst :Subst,
		    withPrivate :Bool,
		    selfType :Type,
		    selfTypeSubst :Subst,
	            callback :Fun2(Method, Subst, Void))
  {
    let subst = CompositeSubst.new(
		   CompositeSubst.new(cplSubst, subst),
		   ConsSubst.new(class_.selfTypeSig,
				 SubstType.new(selfType, selfTypeSubst),
				 EmptySubst.instance
				 )
		 ),

    let seen = Set(:Symbol).new,

    class_.methodDictionaries.do(fun(dict :KeyedContainer(Symbol,Method)) {
      dict !== tycoon.tl.pool.poolMethods ? {
	dict.keysAndElementsDo(fun(selector :Symbol, method :Method) {
	  !method.isPrivate || { withPrivate } ? {
	    !seen.includes(selector) ? {
	      seen.add(selector),

	      callback[method, subst]
	    }
	  }
	})
      }
    })
  }

  (* force recompute of cplSubst *)
  resetCPL { _cplSubst := nil }

  cplSubst :Subst {
    (* this must be done lazily, because expose must evaluate to the receiver
       which must happen after class.typeIde.type := ClassInstanceType(class)
    *)
    _cplSubst.isNil ? {
      _cplSubst := cpl.inject(EmptySubst.instance,
		  fun(subst :Subst, ct :CPLType) {
		    ct.expose(subst, false, fun(exposed :Type, es :Subst) {
		      exposed.visitor.
			ifClassInstanceType(fun(exposed :ClassInstanceType) {
			  CompositeSubst.new(es, ConsSubst.new(
			    exposed.class_.selfTypeSig,
			    IdeType.new(class_.selfTypeSig),
			    subst)
			  )
			}).
		      visitType(exposed)
		    })
		  })
   },

   _cplSubst
 }

 checkSubClassInstanceType(big :ClassInstanceType, subst :Subst, bigSubst :Subst)
 {
   subst == EmptySubst.instance && { bigSubst == EmptySubst.instance } && { class_.isSubClassOf(big.class_) } ?
   { (* Subclassing implies Subtyping *) }
   :
   { super.checkSubClassInstanceType(big, subst, bigSubst) }
 }

  (* called by TypeChecker, check the validity of the CPL *)
 checkCPL
 {
   (* may indicate that superclasses have changed --- and their Self *)
   _cplSubst := nil,
   
   (* maps from Method selector to Method last found
   *)
   let seen = Dictionary(:Symbol, :Method).new,

   class_.methodDictionaries.reverseReader.do(fun(d :KeyedContainer(Symbol, Method)) {
     d.do(fun(m :Method) {
       seen.includesKey(m.selector) ? {   (* Method overridden *)
         let over = seen[m.selector],

	 setError2(m.pos, over.pos, "Public method overridden by private: "+m.selector, {
	   m.isPrivate && {!over.isPrivate} ? {
	     raiseError
	   }
	 }),
	 
	 setError2(m.pos, over.pos, "Overriding method not subtype: "+m.selector, {
	   m.methodType.checkSubType(over.methodType, cplSubst, cplSubst)
	 })
       },

       seen[m.selector] := m
     })
   })
 }

private

  _cplSubst :Subst  (* holds the subst for the whole CPL *)

methods

  _init1(c :ClassPublic)
  {
    class_ := c
  }

;

