class Compiler
super TWL
metaclass CompilerClass
public

errorLog :ErrorLog,
(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 ### the error log should be specific to each activation of the compiler!
       no guarantee what happens when doing multiple compilations in parallel now. *)

(* target machine *)
vmInterface :VMInterface

methods

simpleEval(self_ :Object, inClass :ClassPublic, expression :Value, errorLog :ErrorLog) :Object
{
  let selfTypeSig = inClass.selfTypeSig,
  let selfSig = ValueIde.new1(selfTypeSig.pos, "self", selfTypeSig.type),
  let environment = Dictionary(:ValueIde,:Object).new,
  environment[selfSig] := self_,

  eval(environment, inClass, expression, errorLog)
}

eval( environment :Dictionary(ValueIde, Object),
      inClass :ClassPublic,
      expression :Value,
      errorLog :ErrorLog) :Object
{
  evalChecked(environment, inClass, expression, errorLog, false)
}

evalChecked( environment :Dictionary(ValueIde, Object),
             inClass :ClassPublic,
             expression :Value,
             errorLog :ErrorLog,
	     checked :Bool) :Object
{
  (* create a closure for <expression>,
     compile it and execute it. *)
  let f = CompiledFun.new(
    expression.pos,
    (* domain *) EmptyList.new,
    (* range *) VoidType.instance,   (* ### should be Object *)
    (* body *) expression),

  let selfTypeSig = inClass.selfTypeSig,

  let env = Scoper.new(selfTypeSig, errorLog, inClass.classManager.typeManager),

  env.withSignatures(inClass.domain, {
    env.withSignature(selfTypeSig, {
      env.withSignatures( List.fromReader(environment.keys), {
	let f1 = f.scope(env),
	assert f1 == f
      })
    })
  }),

  checked && { !errorLog.hasErrors } ? {
    try({
      tycoon.tl.typeChecker.checkValue(expression)
    }, fun(e :Exception) {
      errorLog.error(expression.pos, e.printString)
    })
  },
    
  !errorLog.hasErrors
  ? { let globalVars = Bindings.new,
      let closure = newClosure(environment.size+1),
      let var idx = 1,
      environment.keysAndElementsDo(fun(i :ValueIde, o :Object) {
        i.celled
	? { assert o."class" == Cell }
	: { i.setImmutable },
        globalVars.add( GlobalVar.new(i, idx) ),
	closure.__basicAtPut(idx, o),
	idx := idx + 1
      }),

      self.errorLog := errorLog,
      f.compile(globalVars, nil, self),
      f.patchClass(inClass),
      closure.__basicAtPut(0, f),

      !errorLog.hasErrors
      ? { root.active
	  ? { closure[] }
	  : { closure } }
      : { nil } }
  : { nil }
}

(* for the MethodManagers *)
getSelectorId(selector :Selector) :Int
{ selectorIndex.memoize(selector, {
    root.newSelectorId(selector)
  })
}

private

(* selectors, active *)
root :Root,
selectorIndex :Dictionary(Selector, Int)

methods

newClosure(n :Int) :Fun0(Object)
{
  root.active
  ? { (* ### should use a builtin _newClosure *)
      assert n <= 3,
      let f1 = n,
      let f2 = n+1,
      let f3 = n+2,
      let result = fun():Object{ f1 * f2 * f3 },
      assert result.__basicSize >= n,
      result }
  : { _typeCast(MutableArray(:Object).new(n), :Fun0(Object)) }
}
  
makeSelectorIndex
{
  (* ### could be a normal Dictionary because Selector defines
         equality and hash exactly as below *)
  selectorIndex :=
    FunDictionary.new(
      fun(s1 :Selector, s2 :Selector) {
        s1.symbol == s2.symbol && { s1.arity = s2.arity }
      },
      fun(s :Selector) {
        s.symbol.equalityHash + s.arity
      }),
  root.selectors.keysAndElementsDo(fun(id :Int, s :Selector) {
    selectorIndex[s] := id
  })
}

_init :Self
{ super._init,
  makeSelectorIndex,
  self
}
;
