class SendValue
super Value, ApplyMixin
metaclass SendValueClass
public
receiver :Value,  (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 modified by scoper *)
selector :Symbol,
args :List(Value)

methods

isSend :Bool
{ true }

asSend :SendValue
{ self }

prettyPrint(out :Printer)
{
  receiver.isLeaf | receiver.isSend  ? {
    receiver.prettyPrint(out)
  } : {
    (* for cases like "(x := bla).isNil" *)
    out.write('('),
    receiver.prettyPrint(out),
    out.write(')')
  },
  out.write('.'),
  selector.printOn(out),
  !args.isEmpty ? {
    (* all arguments up to the first non-leaf arg are
       printed on the same line.  *)
    out.write('('),
    out.withRelIndent(2, {
      let var complex = false,
      args.doBetween(fun(arg :Value) {
	arg.prettyPrint(out),
	complex := complex || { !arg.isLeaf }
      }, {
        out.writeAll(complex ? {",\n"} : {", "})
      }),
      out.write(')')
    })
  }
} 

children: Reader(Value)
{
  List.cons(receiver, args).reader
}

scope(env :Scoper) :SendValue
{
  receiver := env.scope(receiver),
  args := env.scopeList(:Value, args),
  self
}

genCode(backEnd :MethodManager)
{ receiver.genCode(backEnd),
  let nbValargs = genArgs(backEnd),
  backEnd.send(selector, nbValargs)
}

genCodeReturn(backEnd :MethodManager)
{ receiver.genCode(backEnd),
  let nbValargs = genArgs(backEnd),
  backEnd.sendTail(selector, nbValargs)
}

genArgs(backEnd :MethodManager) :Int
{
  let var nbValargs = 0,
  args.do(fun(v:Value){
    !v.isType ? {
      v.genCode(backEnd),
      nbValargs := nbValargs + 1
    }
  }),
  nbValargs
}

private methods

  doCheck(T <: Void, cont :Fun2(Type, Subst, T)) :T
  {
    let var receiverType :Type = nil,
    let var receiverSubst :Subst = nil,
    
    receiver.check(fun(rt :Type, rs :Subst) { receiverType := rt, receiverSubst := rs }),

    let rtString = receiverType.reduce(receiverSubst, fun(t :Type, :Subst) { t.printString }),
    
    setError(pos, "Method not found: "+rtString+"::\""+selector+"\" of receiver \""+receiver.printString+"\"", {
      receiverType.lookup(selector, receiverSubst, true,
	fun(m :Method, subst :Subst) {
	  m.isPrivate ? {
	    isSelfSend || { isMetaClassSend(receiverType) } ? {} : {
	      setError(pos, "Private method access: "+rtString+"::\""+selector+"\" of receiver \""+receiver.printString+"\"", {
		raiseError
	      })
	    }
	  },
	  applyArgs(pos, m.methodType.domain, args, subst, subst, m.methodType.range, true, true, false, cont)
	}
      )
    })
  }

  isSelfSend :Bool {
    receiver.isIde && { receiver.asIde.ide.name = "self" || { receiver.asIde.ide.name = "super" }}
  }

  (* Hopefully, the Instance ide of ConcreteClass is preserved over the 'let instance = _new'
     until this private send *)
  isMetaClassSend(receiverType :Type) :Bool {
    let var receiverIde :TypeIde = nil,
    
    typeChecker.currentClass.isNotNil && { typeChecker.currentClass."class" == MetaClass } && {
      receiverType.visitor.
        ifSubstType(fun(receiverType :SubstType) {
	  receiverType.type.visitor.
	    ifIdeType(fun(receiverType :IdeType) {
	      receiverIde := receiverType.ide
	    }).
	    otherwise(fun(:Type) { nil }).
	  visitType(receiverType.type)
	}).
	ifIdeType(fun(receiverType :IdeType) {
	  receiverIde := receiverType.ide
	}).
	otherwise(fun(:Type) { nil }).
      visitType(receiverType),

      (* Either receiverIde is nil or it contains the TypeIde of the type of the receiver *)

      receiverIde == ConcreteClass.domain[0] || {
      receiverIde == AbstractArrayClass.domain[1] || {
      receiverIde == CStructClass.domain[0] || {
      receiverIde == AbstractStringClass.domain[0] }}}
    }
  }

;


