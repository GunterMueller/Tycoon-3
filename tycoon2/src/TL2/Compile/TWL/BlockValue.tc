class BlockValue
super Value
metaclass BlockValueClass
public
values :List(Value)
methods

isBlock :Bool		{ true }
asBlock :BlockValue	{ self }

prettyPrint(out:Printer)
{
  values.isEmpty ? {
    out.writeAll("(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
empty*)")
  } : {
    let simple = isSimple,
    values.doBetween(fun(v:Value) {
      v.prettyPrint(out)
    }, {
      out.write(','),
      simple ? { out.space } : { out.nl }
    })
  }
}

noSideEffect :Bool
    (* true => evaluating this expression in an ignore context has no effect. *)
{ values.isEmpty  (* conservative approx. *)
}

children :Reader(Value)
{
  values.reader
}

scope(env :Scoper) :BlockValue
{
  values := env.scopeList(:Value, values),
  self
}

genCode(backEnd :MethodManager)
{ let last = genButLast(backEnd),
  last.genCode(backEnd)
}

genCodeIgnore(backEnd :MethodManager)
{ values.do(fun(v :Value) {
    v.genCodeIgnore(backEnd)
  })
}

genCodeReturn(backEnd :MethodManager)
{ let last = genButLast(backEnd),
  last.genCodeReturn(backEnd)
}

genCodeBranch(backEnd :MethodManager, dest :MMLabel, branchIf :Bool)
{ let last = genButLast(backEnd),
  last.genCodeBranch(backEnd, dest, branchIf)
}

genButLast(backEnd :MethodManager) :Value
{ values.isEmpty ? fun():Value {
    LiteralValue.new1(nil, nil)
  } : {
    let var last = values.head,
    values.tail.do(fun(v :Value) {
      let savedSp = backEnd.sp,
      last.genCodeIgnore(backEnd),
      assert savedSp = backEnd.sp,
      last := v
    }),
    last
  }
}

private methods

  doCheck(T <: Void, cont :Fun2(Type,Subst, T)) :T
  {
    let var resultType :Type = VoidType.instance,
    let var resultSubst :Subst = EmptySubst.instance,

    values.do(fun(v :Value) {
      v.check(fun(t :Type, s :Subst) { resultType := t, resultSubst := s })
    }),

    cont[resultType, resultSubst]
  }



;


