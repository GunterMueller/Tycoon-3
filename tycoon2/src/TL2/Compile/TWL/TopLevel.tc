class TopLevel
super TWLParseUnitVisitor(Void), TWL
metaclass TopLevelClass
public

printByteCode :Bool,
printTycoonSource :Bool,
typeCheck :Bool,

errorLog :ErrorLog,

(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 used resources *)
scanner :ReentrantTWLScanner,
parser :AbstractParser(TWLParseUnit),
compiler :Compiler,
classManager :ClassManager,
pool :Pool,
loader :ClassLoader

methods

file(path :String)
{
  let var searchPath = tycoon.ansiC.getenv("TL2_PATH"),
  searchPath.isNil ? { searchPath := tycoon.os.fs.currentPath },
  let resolvedPath = tycoon.os.fs.search(searchPath, path),
  resolvedPath.isNotNil
  ? { let f = verboseOpen(resolvedPath),
      f.isNotNil
      ? { tycoon.stdout.writeln("[Parsing "+path+"]"),
	  compile(path, f, true, false) } }
  : { errorLog.error(SourcePos.new(path,0,0), "Not found in "+searchPath) }
}

string(str :String)
{
  compile("<string>", StringInput.new(str), false, false)
}

stdin
{
  compile("<stdin>", tycoon.stdin, false, true)
}

(* TWLParseUnitVisitor... *)

visitClass(builder :ClassBuilder)
{ builder.build(compiler, classManager, errorLog) }

visitDefine(definitions :List(Ide))
{
  definitions.do(fun(i:Ide) {
    i.isValueIde
    ? { let s =
          Scoper.new( classManager.get("Nil").typeIde,  (* ## ?? *)
		      errorLog,
		      classManager.typeManager),

	i.type := s.scope(i.type), (* scope(i) doesn''t do the job *)
	!errorLog.hasErrors
	? { pool.defineVariable(i.asValueIde) } }
     : { errorLog.error(i.pos, "pool variable must be value, not type: "+i.name) }
  })
}

visitBindings(bindings :BlockValue)
{
  let inClass = classManager.get("Nil"),
  let selfTypeSig = inClass.selfTypeSig,
  let selfSig = ValueIde.new1(selfTypeSig.pos, "self", selfTypeSig.type),
  let environment = Dictionary(:ValueIde,:Object).new,
  environment[selfSig] := nil,

  (* evalute "fun(){ ...bindings... }", giving a closure (Fun0).
     The user code is not executed until the closure is applied. *)

  let thunkExpression =
    CompiledFun.new(
      bindings.pos,
      (* domain *) EmptyList.new,
      (* range *) nil,
      (* body *) bindings),
  let thunk =
    compiler.evalChecked(environment, inClass, thunkExpression, errorLog, typeCheck),

  !errorLog.hasErrors ? {
    printTycoonSource
    ? { bindings.print, tycoon.stdout.nl },
    printByteCode
    ? { thunkExpression.disassembleOn(
	  Printer.new(tycoon.stdout),
	  ByteCodeReader.new(compiler.vmInterface, classManager.root)),
	tycoon.stdout.nl },

    classManager.root.active ? {
      try({
        assert thunk."class" == Fun0,
	let thunk = _typeCast(thunk, :Fun0(Object)),
	let result = thunk[],
	result.print,
	tycoon.stdout.nl
      }, fun(e:Exception){
	tycoon.stdout.writeAll("Exception: "),
	e.print,
	tycoon.stdout.nl
      })
    }
  }
}

visitDo(pos :SourcePos, command :String, args :List(String))
{
  doCommands.lookup(command,
    fun(f :Fun2(SourcePos, List(String),Void)) {
      f[pos, args]
    },
    { errorLog.warning(pos, "ignored unknown DO command: "
			    +command)
    })
}

private methods

doCommands :Dictionary(String, Fun2(SourcePos, List(String),Void))
{
  let commands = Dictionary.new,
  commands["load"] :=
    fun(pos :SourcePos, args :List(String)) {
      args.size = 1
      ? { let arg = args[0],
	  tycoon.stdout.writeln("[Including "+arg+"]"),
	  file(arg) }
      : { errorLog.error(pos, "DO load: expected one argument, found "
			      +args.size.printString) }
    },
  commands["exit"] :=
    fun(pos :SourcePos, args :List(String)) {
      tycoon.ansiC.exit(0)
    },
  commands["make"] :=
    fun(pos :SourcePos, args :List(String)) {
      loader.update
    },
  commands["help"] :=
    fun(pos :SourcePos, args :List(String)) {
      tycoon.stdout.writeln("Known DO commands:"),
      commands.keys.do(fun(s:String) {
        tycoon.stdout.writeln(s)
      })
    },
  commands
}

compile(where :String, input :Input, closeWhenFinished :Bool, interactive :Bool)
{
  errorLog.reset,
  let s = scanner.scan(where, input, errorLog),

  tryFinally({
    parseLoop(s, interactive)
  }, {
    closeWhenFinished ? { input.close }
  })
}

verboseOpen(path :String) :File
{
  try({ File.openRead(path) },
      fun(e:Exception) {
	errorLog.error(SourcePos.new(path,0,0), "Could not open file: "+e.printString),
	nil
      })
}

parseLoop(s :TWLScanner, interactive :Bool)
{
  interactive
  ? { tycoon.stdout.writeAll("|> ") },
  let u =
    try({
      parser.parse(s,
	fun(tok :Token(Object)) {
	  errorLog.error(s.userState.position, "parse error on "+tok.printString),
	  nil
	})
    }, fun(e:Exception){
      (* ignore ErrorLogErrors produced by the Scanner *)
      e."class" !== ErrorLogError
      ? { e.raise }
      : { nil }
    }),
  u.isNotNil
  ? { u.accept(self),   (* calls back to a visitFoo method *)
      errorLog.hasErrors ? { tycoon.stdout.writeln("There were errors.") },
      errorLog.reset,
      parseLoop(s, interactive) }
}

tryFinally(body :Fun0(Void), finally :Fun0(Void))
{ body[],
(* try({ body[] },
    fun(e:Exception) {
      finally[],
      e.raise
    }), *)
  finally[]
}

_init :Self
{ super._init,
  errorLog := ErrorLog.new,
  let verbose = !classManager.root.active,
  printTycoonSource := verbose,
  printByteCode := verbose,
  typeCheck := false,
  self
}
;
