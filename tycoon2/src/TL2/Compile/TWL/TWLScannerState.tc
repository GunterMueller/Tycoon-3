(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 user state for the TWL scanner *)
class TWLScannerState
super TWL
metaclass TWLScannerStateClass
public 

scanner :TWLScanner,

where :String,
line :Int,
lastNewline :Int,  (* byte position of last newline encountered *)

nesting :Int,   (* comment nesting level *)

errorLog :ErrorLog,

(* shared by all TWL scanners *)
keywords :Dictionary(String, ValueTerminal(SourcePos))

methods

position :SourcePos
{
  SourcePos.new(where, line, column)
}

(* return the current token as an identifier or keyword *)
identify(ident :ValueTerminal(Positioned(String))) :Token(Object)
{
  let token = scanner.token,
  keywords.lookup(token,
    fun(kw :ValueTerminal(SourcePos)) :Token(Object) {
      kw.token(position)
    },
    { let token =   (* ### bootstrap hack *)
        token = "Class_" ? { "Class" }
	: { token = "MetaClass_" ? { "MetaClass" }
	    : { token }},
      ident.token(Positioned.new(position, token))
    }
  )
}

(* counting line numbers *)

(* the client must call <newline> whenever [s]he meets a '\n' in the source *)
newline
{
  line := line + 1,
  lastNewline := scanner.readPos
}

(* 
line :Int
{ _line }
*)

column :Int
{
  scanner.tokenPos - lastNewline
}

error(ch :Char)
{
  errorLog.error(position,
    ch.isNil
    ? { "Unexpected end of input" }
    : { "Unexpected character: "+ch.printString+" ("+ch.asInt.printString+")" }),
  errorLog.raiseError
}

private methods

_init :Self
{ super._init,
  line := 1,
  lastNewline := 0,
  self
}
;



