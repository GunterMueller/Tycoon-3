class ObjectType 
  super TypeImpl
  metaclass AbstractClass

public methods

  visit(T <: Void, visitor :TypeVisitor(T)) :T { visitor.visitObjectType(self) }

  selfTypeSig :TypeIde deferred

  
  checkSubObjectType(big :ObjectType, subst :Subst, bigSubst :Subst)
  {
    (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 to be able to keep big''s Self type, we must lookup on it, not on 'big'
       Unfortunately, we lose the substitutions, if we use the original Self.
       Therefore we build a new one pointing to a SubstType-wrapped big.
    *)
    let bigSelf = big.selfTypeSig,
    let newBigSelf = IdeType.new(SubTypeIde.new1(bigSelf.pos, "bigSelf", SubstType.new(big, bigSubst))),
    
    let mySelf  = self.selfTypeSig,
    let newMySelf = IdeType.new(SubTypeIde.new1(mySelf.pos, "smallSelf", SubstType.new(self, subst))),

    (* furthermore, after lookup, newBigSelf is to be equal to newMySelf *)

    let equalSelfs = ConsSubst.new(newBigSelf.ide, newMySelf, EmptySubst.instance),
    
    newBigSelf.methodsDo(EmptySubst.instance, false, fun(mb :Method, sb :Subst) {
      (* equal both Selfs *)
      let sb = CompositeSubst.new(sb, equalSelfs),

      newMySelf.lookup(mb.selector, EmptySubst.instance, true, fun(ms :Method, ss :Subst) {
	ms.isPrivate ? {
	  raiseError
	},

	(* when subtyping the methods, we must ensure that both Self types are the same.
	   Therefore the subtitution is enlarged by [ newMySelf / newBigSelf ]
	*)
	ms.methodType.checkSubType(mb.methodType, ss, sb)
      })
    })
  }

  checkSubNilType(big :NilType, subst :Subst, bigSubst :Subst) { raiseSubTypeError(self, big) }

  checkSubApplyType(big :ApplyType,  subst :Subst, bigSubst :Subst) {
    big.expose(bigSubst, true, fun(big :Type, bigSubst :Subst) { checkSubType(big, subst, bigSubst) })
  }

  checkSubOperType(big :OperType, subst :Subst, bigSubst :Subst) {
    raiseSubTypeError(self, big)
  }


  
  
  apply(T <: Void, args :List(Type), subst :Subst, argsSubst :Subst, exact :Bool, cont :Fun2(Type, Subst, T)) :T
  {
    args.isEmpty ? { cont[self, subst] } : { raiseError } 
  }

  checkApplication(args :List(Type), subst :Subst)
  {
    args.isEmpty ? { } : { raiseError } 
  }

    
private methods

  doExpose(T <: Void, subst :Subst, exact :Bool, cont :Fun2(Type, Subst, T)) :T
  {
    cont[self, subst]
  }
  

;
