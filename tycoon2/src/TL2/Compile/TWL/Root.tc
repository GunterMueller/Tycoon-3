class Root
super Object
metaclass RootClass
public

(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
threads :List(Thread),         (* circular list of threads *)*)
thread :Thread(Void),
classTable :MutableArray(Class_),     (* mapping class ids to class objects *)

(* Selector Id <n> uses selector <selectorTable[n]> and takes
   <arityTable[n]> arguments. *)
selectorTable :MutableArray(Symbol),
arityTable :ByteArray,

true_  :Bool,
false_ :Bool,
nil_ :Nil,
charTable :Array(Char),

symbolTable :FunSet(Symbol),

selectorTableSize :Int,
nextClassId :Int,

finalizer :Finalizer,

(* class name --> TspDescriptor *)
storeDescriptors :Dictionary(String, TspDescriptor),

active :Bool  (* is this the current machine's root object? *)

methods

newSelectorId(selector :Selector) :Int
{
  (* handmade GapArrays *)
  let i = selectorTableSize,
  selectorTable.size = i ? {
    let newSelectorTable = MutableArray.new(2*i),
    let newArityTable = ByteArray.new(2*i),
    newSelectorTable.replace(i, 0, selectorTable, 0),
    newArityTable.replace(i, 0, arityTable, 0),
    selectorTable := newSelectorTable,
    arityTable := newArityTable
  },
  selectorTable[i] := selector.symbol,
  arityTable[i] := selector.arity,
  selectorTableSize := selectorTableSize + 1,
  i
}

selectors :FunSequence(Selector)
{
  FunSequence.new(
    fun(i :Int) { idToSelector(i) },
    { selectorTableSize })
}

idToSelector(id :Int) :Selector
{
  Selector.new(selectorTable[id], arityTable[id])
}

registerClass(class_ :Class_)
{
  let desc = class_.storeDescriptor,
  class_.id := newClassId(desc.layout, desc.format),

  (* handmade GapArrays *)
  class_.id >= classTable.size ? {
    let newSize = (class_.id+1).max(2 * classTable.size),
    let newClassTable = MutableArray.new(newSize),
    newClassTable.replace(classTable.size, 0, classTable, 0),
    classTable := newClassTable
  },
  classTable[class_.id] := class_
}

classes :Reader(Class_)
{ classTable.keys
     .select(fun(i:Int){ classTable[i].isNotNil })
     .map(fun(i:Int){ classTable[i] })
}
				     

private methods

_init :Self
{ super._init,

  (* ### threads := EmptyList.new, *)

  symbolTable := Symbol.symbolTable,
  
  classTable := MutableArray.new(10),
  nextClassId := 0,

  selectorTable := MutableArray.new(10),
  arityTable := ByteArray.new(10),
  selectorTableSize := 0,

  true_ := true,
  false_ := false,
  let ma = MutableArray.new(256),
  ma.keys.do(fun(i :Int) {
    ma[i] := i.asChar
  }),
  charTable := Array.fromSequence(ma),
  active := false,
  self
}

newClassId(layout :Int, descriptor :String) :Int
{
  active
  ? { _newClassId(layout, descriptor) }
  : { let result = nextClassId,
      nextClassId := nextClassId+1,
      result }
}

_newClassId(layout :Int, descriptor :String) :Int
  builtin
;
