(*
cd $HOX_HOME

(* launch store including programming environment *)
tycoon2 TL2.ts
(* create and dump a new memory image *)
DO load "Compile/TWL/bootstrap2.tyc";
DO exit;
(* turn dump into store *)
tycoon2 -bootstrap dump
(* unfold store *)
tycoon2 Bootstrap.ts
(* assume all classes are typechecked *)
Array.fromContainer(tycoon.tl.typeChecker.agenda).do(
  fun(c :ClassPublic) {
    tycoon.tl.typeChecker.ignore(c)
  }
);
(* that`s all *)
tycoon.saveSystem;

*)
Date.now;

define newTL :TL;
let root = Root.new(tycoon.hoxHome+"/src/tm/storeDescriptors.tab"),
let pool = Pool.new,
let vmInterface =
  VMInterface.new(
    tycoon.hoxHome+"/src/tm/builtins.tab",
    tycoon.hoxHome+"/src/tm/opcodes.tab"),
newTL := TL.new(root,pool,vmInterface);

(* Hack: pretend that AbstractClass is already known *)
newTL.typeManager.newClassSignature("AbstractClass");

let f = File.openRead(tycoon.hoxHome+"/src/tm/classids.tyc"),
let script = f.readString(f.size.asInt),
f.close,
newTL.topLevel.string(script+";");

newTL.topLevel.file("SystemTracer/BootStrap.tyc");

Date.now;

(* ------------------------------------------------------------ *)
(* newTL is functional now.
   Here come the actual classes needed for bootstrap:
 *)

newTL.loader.registerDirectory("Standard");
newTL.loader.registerFile("Util/Util.tc");
newTL.loader.registerFile("Util/StandardDateParser.tc");
newTL.loader.registerFile("Util/MD5.tc");
newTL.loader.registerFile("Util/MD5Class.tc");
newTL.loader.registerDirectory("Util/Graphs");
newTL.loader.registerDirectory("Util/Graphs/Simple");
(*newTL.loader.update;*)
newTL.loader.registerDirectory("Compile");
newTL.loader.registerDirectory("Compile/Scan");
newTL.loader.registerDirectory("Compile/Scan/Eager");
newTL.loader.registerDirectory("Compile/Parse");
newTL.loader.registerDirectory("Compile/Parse/Compact");
(*newTL.loader.update;*)
newTL.loader.registerDirectory("Compile/TWL");
newTL.loader.registerDirectory("Compile/TWL/BackEnd");
newTL.loader.registerDirectory("SystemTracer");
newTL.loader.update;

Date.now;

newTL.root.storeDescriptors["Class"] := ClassDescriptor.instance;

newTL.topLevel.string("define tycoon :Tycoon");

(* manually run the compiler on the startup code
   and pass the root,pool and vmInterface objects in *)
let path = tycoon.hoxHome+"/src/TL2/Compile/TWL/startup.tyc",
let errorLog = newTL.topLevel.errorLog,
let f = File.openRead(path),
let s = newTL.scanner.scan(path, f, errorLog),
let startup = newTL.parser.parse(s, fun(t:Token(Object)){t.print}),
f.close,
assert startup."class" == TWLPUBindings,
let startup = _typeCast(startup, :TWLPUBindings),
let block :BlockValue = startup.b,
assert block.values.size = 1,
let funExpr = block.values[0],
assert funExpr."class" == CompiledFun,
assert _typeCast(funExpr, :CompiledFun).domain.size = 3,
let funExpr =
  CompiledFun.new(nil, List.with0, nil,
    SendValue.new1(nil, funExpr, Symbol.new("[]"),
      List.with3(
        LiteralValue.new1(nil, newTL.root),
        LiteralValue.new1(nil, newTL.pool),
        LiteralValue.new1(nil, newTL.vmInterface)))),
newTL.compiler.simpleEval(nil, newTL.classManager.get("Nil"), funExpr, errorLog),
(* as a side effect, funExpr is compiled. *)
newTL.root.thread := funExpr;

tycoon.ansiC.getenv("TYCOON_FINALIZE").isNotNil ? {
  newTL.classManager.finalize
};

Date.now;
newTL.root.classes.do(fun(c:Class_) {
  c.classManager := nil
});
newTL.pool.observers.remove(newTL.classManager);
newTL.pool.observers.remove(newTL.typeChecker);
Tracer.new.traceToFile(newTL.root, "dump");
newTL.root.classes.do(fun(c:Class_) {
  c.classManager := newTL.classManager
});
newTL.pool.observers.add(newTL.classManager);
newTL.pool.observers.add(newTL.typeChecker);
Date.now;

DO exit;
