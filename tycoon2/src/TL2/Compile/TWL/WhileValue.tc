class WhileValue
super Value
metaclass WhileValueClass
public
condition :Value,
body :Value

methods
prettyPrint(out :Printer)
{
  out.writeString("while({ "),
  out.withRelIndent(2, {
    !condition.isSimple ? { out.nl },
    condition.prettyPrint(out)
  }),
  !condition.isSimple ? { out.nl },
  out.writeString("}, {"),
  out.withRelIndent(2, {
    out.nl,
    body.prettyPrint(out)
  }),
  out.writeString("\n})")
}

isSimple :Bool
{ false }

children: Reader(Value)
{
  Array.with2(condition, body).reader
}

scope(env :Scoper) :WhileValue
{
  condition := env.scope(condition),
  body := env.scope(body),
  self
}

genCodeIgnore(backEnd :MethodManager)
{
    let condL = backEnd.newLabel,
    let loopL = backEnd.newLabel,

    let loopSp = backEnd.sp,
    backEnd.jump(condL),
    (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 assume the loop body is always reached *)
    backEnd.sp := loopSp,
    backEnd.defineLabel(loopL),
    backEnd.sync,
    body.genCodeIgnore(backEnd),
    backEnd.defineLabel(condL),
    condition.genCodeBranch(backEnd, loopL, true),
    (* assume the loop terminates *)
    backEnd.sp := loopSp
}

genCode(backEnd :MethodManager)
{
  genCodeIgnore(backEnd),
  backEnd.loadLiteral(nil)
}

genCodeBranch(backEnd :MethodManager, dest :MMLabel, branchIf :Bool)
{ backEnd.errorLog.error(pos, "while loop used as a condition"),
  super.genCodeBranch(backEnd, dest, branchIf)
}


private methods

  doCheck(T <: Void, cont :Fun2(Type, Subst, T)) :T
  {
    condition.check(fun(t :Type, s :Subst) {
      setError(pos, "While condition must be subtype of Bool", {
        t.checkSubType(IdeType.new(Bool.typeIde), s, EmptySubst.instance)
      })
    }),

    body.check(fun(:Type, :Subst) {}),

    (* a while loop has no return type *)
    cont[VoidType.instance, EmptySubst.instance]
  }


;



