class TypeChecker
  super TWL, TypeCheckMixin
  metaclass TypeCheckerClass

public

  logTypeChecks   :Bool, (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 dump checkType *)
  logValueChecks  :Bool, (* dump checkValue *)
  logSubTypeTests :Bool, (* dump checkSubType *)
  abortCheck      :Bool, (* abort now ! *)
  maxDepth        :Int   (* recursion limitation *)
  
methods

  (* public interface to typechecking *)

  checkClass(c :ClassPublic) {
    protect({
      trace(c.pos, "While checking class "+c.name, {
	_currentClass := c,
	_depth := 0,
	unificationDB.reset,

	tycoon.stdout.writeln("Checking class "+c.name),

	c.domain.do(fun(i :Ide) {
	  trace(i.pos, "While checking formal type parameter "+i.name, {
	    i.type.checkType(EmptySubst.instance)
	  })
	}),

	checkMeta(c),
	checkSelf(c),
	checkCPL(c),

	c.methodDictionary.do(fun(m :Method) { checkMethod(m) })
      })
    }, {
      unificationDB.reset,
      _currentClass := nil
    })
  }
  

  check {
    let var typeError = false,
    let var c :ClassPublic = nil,

    while({ !agenda.isEmpty && { !typeError }}, {
      try({
	c := agenda.reader.read,
	checkClass(c),
	agenda.removeKey(c.name)
      }, fun(e :Exception) {
        unificationDB.reset,
	tycoon.stdout << e << "\n",
	tycoon.stdout << c.name << " has not been successfully typechecked.\n",
	typeError := true,
	nil
      })
    })
  }

  checkValue(value :Value) :Type
  {
    _currentClass := nil,
    unificationDB.reset,
    _depth := 0,

    protect({
      value.check(fun(t :Type, s :Subst) { t.reduce(s, fun(t :Type, s :Subst) { t }) })
    }, {
      unificationDB.reset
    })
  }

  ignore(c :ClassPublic)
  {
    agenda.removeKey(c.name)
  }
  
  currentClass :ClassPublic { _currentClass }

  
  (* called by Compiler *)
  classChanged(c :ClassPublic)
  {
    (* give a type to c''s typeIde *)
    c.typeIde.type := c.domain.isEmpty ? fun() :Type {
      let t :Type = ClassInstanceType.new(c)
    } : {
      OperType.new(c.domain, ClassInstanceType.new(c))
    },

    agenda[c.name] := c,

    (* ## too slow ? *)
    dependencies.do(fun(s :Set(String)) {
      s.remove(c.name)
    })

    (* globalIdeChanged is called when this class is inserted into the pool *)
  }

  globalIdeChanged(i :String)
  {
    dependencies.includesKey(i) ? {
      dependencies[i].do(fun(c :String) {
        let dependingClass = classManager.get(c),
        agenda[c] := dependingClass
      })
    },

    tycoon.tl.classManager.classTable.includesKey(i) ? {
      (* is i a class ??? *)
      tycoon.tl.classManager.subclasses(tycoon.tl.classManager.get(i)).do(fun(c :ClassPublic) {
	(* classes inheriting from the changed class
	   will have to adjust their cplSubst since it
	   contains the superclasses'' formal type params
	   which change if the class is recompiled
	*)

	let t = c.asType,
	t.isNotNil ? {
	  t.visitor.
	    ifClassInstanceType(fun(cit :ClassInstanceType) { cit.resetCPL }).
	    ifOperType(fun(ot :OperType) {
	      ot.visitor.ifClassInstanceType(fun(cit :ClassInstanceType) { cit.resetCPL }).visitType(ot.range)
	    }).
	  visitType(t)
	}
      })
    }
  }

  (* called in method-lookup / typeIde resolution *)
  
  globalIdeReferenced(i :String)
  {
    currentClass.isNotNil ? {
      dependencies.lookup(i, fun(dependants :Set(String)) {
	dependants.add(currentClass.name)
      }, {
	dependencies[i] := Set.with1(currentClass.name)
      })
    }
  }
  
  (* called by types *)

  typeChecked(type :Type, subst :Subst, check :Fun0(Void))
  {
    abort,
  
    logTypeChecks ? {
      tycoon.stdout << "Checking type :" << type << subst << "\n"
    },
    
    check[]
  }

  valueChecked(T <: Void, v :Value, check :Fun0(T)) :T
  {
    abort,
  
    logValueChecks ? {
      tycoon.stdout << "Checking value :" << v << "\n"
    },
    
    check[]
  }

  checkSubType(small :Type, big :Type, sSubst :Subst, bSubst :Subst, check :Fun0(Void)) {
    abort,
  
    logSubTypeTests ? {
      tycoon.stdout <<
        "{ Checking subtype :" <<
	small <<
	sSubst <<
	" <: " <<
	big <<
	bSubst <<
	"\n"
    },
    
    subTypeDB.consult(small, big, sSubst, bSubst, {
      let unistate = unificationState,
      try({
        check[]
      }, fun(e :Exception) {
        retractTo(unistate),
	logSubTypeTests ? { tycoon.stdout << "FAILED }\n" },  
	e.raise
      })
    }),

    logSubTypeTests ? { tycoon.stdout << "DONE }\n" }
  }

  saveUnivar(u :UnifyType) {
    unificationDB.saveUnivar(u)
  }

  unificationState :Int {
    unificationDB.unificationState
  }

  retractTo(unificationState :Int) {
    unificationDB.retractTo(unificationState)
  }

  (* regain some MB *)
  finalize {
    subTypeDB.clear
  }

private 

  (* database of proven/being proved subtype relations *)
  subTypeDB     :SubTypeDB,

  (* database of currently instantiated unification variables *)
  unificationDB :UnificationDB,

  (* class being currently checked *)
  _currentClass    :ClassPublic, 

  (* # of entries into the typechecker to avoid infinite recursion *)
  _depth           :Int,  

  (* maps from global ides to class names *)
  dependencies    :Dictionary(String, Set(String)),

  (* classes to be typeChecked *)
  agenda :Dictionary(String, ClassPublic),
  
  classManager :ClassManager,
  pool :Pool

methods

  checkMethod(m :Method) {
    m.methodType.domain.do(fun(i :Ide) {
      i.type.checkType(EmptySubst.instance)
    }),

    m.methodType.range.checkType(EmptySubst.instance),

    m."class" == CompiledMethod ? {
      let m = _typeCast(m, :CompiledMethod),
      unificationDB.reset,
      _depth := 0,
      m.body.isNotNil ? {
	m.body.check(fun(t :Type, s :Subst) {
	  setError(m.pos, "Method body does not conform to declared return type", {
	    t.checkSubType(m.methodType.range, s, EmptySubst.instance)
	  })
	})
      }
    }
  }

  _init :Self {
    subTypeDB := SubTypeDB.new,
    unificationDB := UnificationDB.new,
    
    logTypeChecks   := false,
    logValueChecks  := false,
    logSubTypeTests := false,
    abortCheck      := false,
    maxDepth        := 10000,

    _currentClass    := nil,
    dependencies     := Dictionary.new,
    agenda           := Dictionary.new,

    classManager.typeChecker := self,
    pool.observers.add(self),

      (* insert all pre-bootstrap classes into the agenda *)
    classManager.root.active ? {
      classManager.classTable.do(fun(c :ClassPublic) {
        classChanged(c)
      })
    },
    
    self
  }

  abort {
    _depth := _depth + 1,
    _depth > maxDepth || { abortCheck } ?
      { TypeCheckAbort.new.raise }
  }
    

  checkMeta(c :ClassPublic)
  {
    (* check c''s Metaclass-Declaration
       adds dependency to MetaClass
    *)
    c.metaClassDeclaration.checkType(EmptySubst.instance)

    (* ## check the Instance parameter of ConcreteClass *)
  }

  checkSelf(c :ClassPublic)
  {
    c.selfTypeSig.type.checkType(EmptySubst.instance)
  }

  checkCPL(c :ClassPublic)
  {
    (* depend on superclasses *)
    classManager.superclasses(c).do(fun(c :ClassPublic) { globalIdeReferenced(c.name) }),
    
    let cit = c.typeIde.type.visitor.
      ifClassInstanceType(fun(c :ClassInstanceType) { c }).
      ifOperType(fun(o :OperType) {
        o.range.visitor.
	  ifClassInstanceType(fun(c :ClassInstanceType) { c }).
	visitType(o.range)
      }).
    visitType(c.typeIde.type),

    cit.checkCPL
  }


;
