(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 a ByteCodeWriter can be interpreted as a Visitor.
   Here, <w> visits the byte code instruction at <pos>.
   <pos> is advanced to point behind the decoded instruction. *)
(* On the other hand, ByteCodeReader is a reader for
   byte code instructions (where one byte code instruction corresponds
   to one message to <w>). *)
   
class ByteCodeReader
super BackEnd
metaclass ByteCodeReaderClass
public methods

do(code :ByteArray, w :ByteCodeWriter)
{
  _code := code,
  initLabels(w),   (* fetch labels from w.newLabel and remember byte positions *)
  doPass(w)	   (* the real thing *)
}

jump(l :Label)
{ pos := labels.locate(l) }

next
{
  labels.lookup(pos, fun(l:Label) {
    !l.isDefined ? { out.defineLabel(l) }
  }, { }),
  let op = fetch,
  actions[op][]
}

atEnd :Bool
{ pos = _code.size }

private

vmInterface :VMInterface,
root :Root,
actions :MutableArray(Fun0(Void)),

labels :Dictionary(Int, Label),

_code :ByteArray,
pos :Int,
out :ByteCodeWriter,
realOut :ByteCodeWriter


methods

setOptional(s :String, action :Fun0(Void))
{ vmInterface.opcodes.includesKey(s) ? {
    setAction(s,action)
  }
}

setAction(s :String, action :Fun0(Void))
{ actions[vmInterface.opcodes[s].n] := action }

_init :Self
{
  actions := MutableArray.new(256),
  setAction("send", {
    let sel = fetch16,
    out.send( sel, root.arityTable[sel] )
  }),
  let sendSpecial = {
    let sel = fetch16,
    out.sendSpecial( sel, root.arityTable[sel] )
  },
  setOptional("sendAdd", sendSpecial),
  setOptional("sendSub", sendSpecial),
  setOptional("sendLessOrEqual", sendSpecial),
  setOptional("sendEqual", sendSpecial),
  setOptional("sendNotEqual", sendSpecial),
  setOptional("sendFun0Apply", sendSpecial),
  setOptional("sendFun1Apply", sendSpecial),
  setOptional("sendIsNil", sendSpecial),
  setOptional("sendIsNotNil", sendSpecial),
  setAction("sendSuper", {
    let sel = fetch16,
    out.sendSuper( sel, root.arityTable[sel] )
  }),
  setOptional("sendTail", {
    let sel = fetch16,
    out.sendTail( sel, root.arityTable[sel] )
  }),

  setAction("literal8",	{ out.loadLiteral(fetch) }),
  setAction("literal16",{ out.loadLiteral(fetch16) }),
  setAction("char",	{ out.loadChar(fetch.asChar) }),
  setAction("byte",	{ out.loadByte(fetchSigned) }),
  setAction("short",	{ out.loadShort(fetchSigned16) }),
  setAction("nil",	{ out.loadSpecial(nil) }),
  vmInterface.specialLiterals.keysAndElementsDo(
    fun(o:Object, op :String) {
      setAction(op,	{ out.loadSpecial(o) })
    }),

  setAction("arg",	{ out.loadArgument(fetch) }),
  setAction("local",	{ out.loadLocal(fetch) }),
  setAction("storeLocal", { out.storeLocal(fetch) }),
  setAction("global",	{ out.loadGlobal(fetch) }),

  setAction("cellNew",	{ out.cellNew }),
  setAction("cellLoad", { out.cellLoad }),
  setAction("cellStore",{ out.cellStore }),
  setAction("drop",	{ out.drop(fetch) }),
  setAction("pop",	{ out.pop }),
  setAction("adjust", 	{ out.adjust(fetch) }),
  setAction("closure", 	{ out.closure(fetch) }),
  setAction("sync", 	{ out.sync }),
  setAction("return", 	{ out.return }),
  setAction("ifTrue8", 	{ out.ifTrue(label(pos-1, fetchSigned)) }),
  setAction("ifTrue16", { out.ifTrue(label(pos-1, fetchSigned16)) }),
  setAction("ifFalse8",	{ out.ifFalse(label(pos-1, fetchSigned)) }),
  setAction("ifFalse16",{ out.ifFalse(label(pos-1, fetchSigned16)) }),
  setAction("jump8",	{ out.jump(label(pos-1, fetchSigned)) }),
  setAction("jump16",	{ out.jump(label(pos-1, fetchSigned16)) }),

  (* short forms *)
  for(0,9, fun(i:Int) {    (* 9 = conservative approx. *)
    setOptional("send"+String.with1(Char.digit(i)), {
      let sel = fetch16,
      assert root.arityTable[sel] = i,
      out.send( sel, i )
    })
  }),
  (* do the same for argument, local, storeLocal, global, drop, adjust, closure...? *)
  self
}

initLabels(writer :ByteCodeWriter)
{
  realOut := writer,
  labels := Dictionary.new,
  doPass(NopByteCodeWriter.new),  (* side effect in _label *)
  realOut := nil
}

doPass(w :ByteCodeWriter)
{
  out := w,
  pos := 0,
  while({!atEnd},{
    next
  })
}

label(byteCodePosition :Int, offset :Int) :Label
{
  let dest = byteCodePosition + offset,
  labels.memoize(dest, {
    realOut.newLabel
  })
}

fetch :Int
{
  let f = _code[pos],
  pos := pos + 1,
  f
}

fetchSigned :Int
{ let f = fetch,
  f <= 127 ? { f } : { f - 256 }
}

fetch16 :Int
{ let lo = fetch,
  let hi = fetch,
  (hi."<<"(8)) + lo
}

fetchSigned16 :Int
{ let f = fetch16,
  f <= 32767 ? { f } : { f - 65536 }
}
;


