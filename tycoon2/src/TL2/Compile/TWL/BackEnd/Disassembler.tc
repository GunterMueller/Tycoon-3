class Disassembler
super ByteCodeWriter
metaclass SimpleConcreteClass(Disassembler)
public

labelCnt :Int,
output :List(String),
root :Root,

argumentNames :Array(String),
globalNames :Array(String)

methods

wrln(s :String)
{ output := List.cons(s, output) }

arg1(opcode :String, n :Int)
{ wrln(opcode + " " + n.printString) }

arg1C(opcode :String, n :Int, comment :String)
{ wrln(opcode + " " + n.printString+"\t;; "+comment) }

arg0(opcode :String)
{ wrln(opcode) }

newLabel :Label
{ labelCnt := labelCnt + 1,
  let l = Label.new,
  l.n := labelCnt,
  l
}

defineLabel(l :Label)
{ wrln(l.printString+":") }

(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 emitting *)

send(selectorId :Int, nbArgs :Int)
{ let suffix =
    nbArgs < 6
     ? { String.with1(Char.digit(nbArgs)) }
     : { "" },
  wrln("send"+suffix+" "+root.idToSelector(selectorId).printString)
}

sendSpecial(selectorId :Int, nbArgs :Int)
{
  wrln("sendSpecial "+root.idToSelector(selectorId).printString)
}

sendSuper(selectorId :Int, nbArgs :Int)  (* nbArgs implicit in selectorId *)
{ wrln("sendSuper "+root.idToSelector(selectorId).printString) }

sendTail(selectorId :Int, nbArgs :Int)
{ wrln("sendTail "+root.idToSelector(selectorId).printString) }

loadLiteral(literalIdx :Int)
{ arg1("literal", literalIdx) }

(* special literals *)
loadChar(c :Char)
{ wrln("char "+c.printString) }

loadByte(b :Int)
{ arg1("byte", b) }

loadShort(s :Int)
{ arg1("short", s) }

canLoadSpecial(o :Object) :Bool
{ true }   (* I can if I have to *)

loadSpecial(o :Object)
{ arg0("literal_"+o.printString) }

loadArgument(argIdx :Int)
{ argumentNames.isNotNil
  && { argumentNames.includesKey(argIdx) }
  ? { arg1C("arg", argIdx, argumentNames[argIdx]) }
  : { arg1("arg", argIdx) }
}

loadLocal(localIdx :Int)
{ arg1("local", localIdx) }

storeLocal(localIdx :Int)
{ arg1("storeLocal", localIdx) }

loadGlobal(globalIdx :Int)
{ globalNames.isNotNil
  && { globalNames.includesKey(globalIdx) }
  ? { arg1C("global", globalIdx, globalNames[globalIdx]) }
  : { arg1("global", globalIdx) }
}

cellNew
{ arg0("cellNew") }
  
cellStore
{ arg0("cellStore") }

cellLoad
{ arg0("cellLoad") }
  
drop(n :Int)
{ arg1("drop", n) }

pop
{ arg0("pop") }

adjust(n :Int)
{ arg1("adjust", n) }

closure(nbGlobals :Int)
{ arg1("closure", nbGlobals) }

sync
{ arg0("sync") }

return
{ arg0("return") }

ifTrue(dest :Label)
{ wrln("ifTrue "+dest.printString) }

ifFalse(dest :Label)
{ wrln("ifFalse "+dest.printString) }

jump(dest :Label)
{ wrln("jump "+dest.printString) }

finished :List(String)
{ List.reverse(output) }

private methods

_init :Self
{ super._init,
  labelCnt := 0,
  output := List.with0,
  self
}
;
