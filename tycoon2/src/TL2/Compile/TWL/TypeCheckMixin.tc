class TypeCheckMixin
  super TWL
  metaclass AbstractClass

private methods

  (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 some implementation helpers *)

  (* Wrap these around the actual typetests to have the tests
     included in the backtrace of a type error:

     traceType(t, {
       .. include the actual tests
     }),

  *)

  _trace(T <: Void, trace :TypeCheckTrace, t :Fun0(T)) :T
  {
    try({
      t[]
    }, fun(e :Exception) {
      e."class" == TypeCheckTypeError || { e."class" == TypeCheckAbort } ? {
        _typeCast(e, :TypeCheckError).addTrace(trace)
      },
      e.raise
    })
  }

  trace(T <: Void, pos :SourcePos, msg :String, t :Fun0(T)) :T
  {
    _trace(TypeCheckTrace.simple(pos, msg), t)
  }

  traceType(T <: Void, type :Type, t :Fun0(T)) :T
  {
    _trace(TypeCheckTrace.type(type), t)
  }

  traceSubType(T <: Void, small :Type, big :Type, t :Fun0(T)) :T
  {
    _trace(TypeCheckTrace.subType(small, big), t)
  }

  traceValue(T <: Void, v :Value, t :Fun0(T)) :T
  {
    _trace(TypeCheckTrace.value(v), t)
  }

  setError(T <: Void, pos :SourcePos, msg :String, t :Fun0(T)) :T
  {
    setErrorWithPositions(List.with1(pos), msg, t)
  }

  setError2(T <: Void, pos1 :SourcePos, pos2 :SourcePos, msg :String, t :Fun0(T)) :T
  {
    setErrorWithPositions(List.with2(pos1, pos2), msg, t)
  }

  setErrorWithPositions(T <: Void, pos :Collection(SourcePos), msg :String, t :Fun0(T)) :T
  {
    try({
      t[]
    }, fun(e :Exception) {
      e."class" == TypeCheckTypeError ? {
        let e = _typeCast(e, :TypeCheckError),
	e.error.isNil ? { e.setErrorWithPositions(pos, msg) }
      },
      e.raise
    })
  }

  raiseError :Nil {
    TypeCheckTypeError.new.raise
  }
    
  raiseTypeError(t :Type) :Nil {
    raiseError
  }

  raiseSubTypeError(small :Type, big :Type) :Nil {
    raiseError
  }

  typeChecker :TypeChecker {
    tycoon.tl.typeChecker
  }
 
;
