(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 File: ClassLoader.tc
 Author: Axel Wienberg
   Date: 17-Dec-1996
Purpose: automated reloading of classes

Phase 0:
  The user informs the system about class file locations by
  calling "registerClassFile" either directly or conveniently
  via "registerDirectory" and "registerFile".

  The user calls <update>.
Phase 1:
  All class files that have changed on disc are parsed.
Phase 2:
  The loader traverses all classes in dependency depth-first order and compiles them.

  
Ad 1:
  Creates ClassBuilders in <builders>, in addition to
  those left over from previous runs.
Ad 2:
  If build is successful, the ClassBuilder is removed
  from <builders>.

### the loader assumes that no classes are compiled behind its back:
    if there is a builder for class Foo, we do not verify that it is indeed
    younger than class Foo.
### the fingerprint is computed twice:  once, when checking, and the second
    time, when parsing the file.
*)
	
class ClassLoader
super TWL
metaclass ClassLoaderClass
public methods

(* look for all files with extension ".tc" under directory <path>.
   These are assumed to hold the definition of the class with the corresponding class name.
   <path> is interpreted relative to an element of the environment variable TL2_PATH *)
registerDirectory(relDirPath :String)
{
  let resolvedDirPath = _search(relDirPath),
  resolvedDirPath.isNotNil
  ? { (* ### check if <path> is actually a Directory *)
      let dir = Directory.new(resolvedDirPath),
      let r = dir.reader,
      r.do(fun(c :DirectoryContents) {
	c.case(:Void, fun(:Directory) {
	  (* ignore *)
	},
	fun(f :File) {
	  let fs = tycoon.os.fs,
	  let relPath = fs.composePath(List.with2(relDirPath, fs.lastArc(f.path))),
	  _registerFile(relPath)
	})
      }),
      r.close }
  : { tycoon.stdout.writeln("Cannot find directory "+relDirPath+" in "+tl2Path) }
}

(* register the file in <path>.
   <path> should be of the form   <directory>/<ClassName>.tc
   where <ClassName> consists of alphanumeric characters or underscore.
   The file is assumed to hold class <ClassName>.
   <path> is interpreted relative to an element of the environment variable TL2_PATH *)
registerFile(path :String)
{
  !_registerFile(path)
  ? { tycoon.stdout.writeln("Malformed path (expecting <dir>/<class>.tc): "+path) }
}

(* register the class <className> to reside in file <path>.
   <path> is interpreted relative to an element of the environment variable TL2_PATH. *)
registerClassFile(className :String, path :String)
{
  errorLog.reset,
  let path = tycoon.os.fs.canonicalizePath(path),
  classManager.classTable.lookup(className,
    fun(cl:ClassPublic) {
      cl.pos.where != path
      ? { errorLog.warning(cl.pos, "old definition of class "+cl.name+", moved to "+path),
	  cl.pos := SourcePos.new(path,0,0),
	  cl.sourceTime := Long.fromInt(0) }
    },
    { (* build a dummy (forward) class *)
      let defaultMetaClass =
	CPLType.new(TypeIde.newRef(Positioned.new(nil, "AbstractClass")), emptyList),
      let b =
       ClassBuilder.new(
	 Positioned.new( SourcePos.new(path,0,0),
			 className),
	 (* domain *) emptyList,
	 (* supers *) emptyList,
	 (* selfTypeSig *) nil,
	 (* metaClassDeclaration *) defaultMetaClass),
      b.sourceTime := Long.fromInt(0),  (* infinitely old, needs update *)
      b.publicMethods := b.privateMethods := emptyList,
      b.publicSlots := b.privateSlots := emptyList,
      b.build(compiler, classManager, errorLog)
    })
}

update
{
  errorLog.reset,
  parseNewFiles,
  !errorLog.hasErrors
  ? { tycoon.stdout.writeln("[Checking for unknown class names...]"),
      checkUnknown,
      !errorLog.hasErrors
      ? { makeClasses } }
}

unregisterClass(className :String)
{
  errorLog.reset,
  builders.includesKey(className)
  ? { builders.removeKey(className) },
  classManager.classTable.lookup(className,
    fun(cl:ClassPublic) :Void {
      cl.pos := SourcePos.new("<string>",0,0),
      nil
    },
    { tycoon.stdout.writeln("Unknown class name: "+className)
    })
}

compiler :Compiler
{ _compiler }

classManager :ClassManager
{ _classManager }

scanner :ReentrantTWLScanner
{ _scanner }

parser :AbstractParser(TWLParseUnit)
{ _parser }

(* ### this is a hack to avoid another bootstrap.
       errorLog should be a public slot. *)
errorLog :ErrorLog
{ _errorLog }

"errorLog:="(e :ErrorLog): ErrorLog
{ _errorLog := e }

private

builders :Dictionary(String, ClassBuilder),
_errorLog :ErrorLog,

_scanner :ReentrantTWLScanner,
_parser :AbstractParser(TWLParseUnit),
_compiler :Compiler,
_classManager :ClassManager

methods

(* like registerFile, but no error message. Instead,
   returns true iff <path> has a sensible format. *)
_registerFile(path :String) :Bool
{
  let fs = tycoon.os.fs,
  fs.pathExtension(path) = "tc"
  && { let className = fs.lastArc(fs.pathBase(path)),
       className.all(fun(c:Char){ c.isAlphaNumeric || { c = '_' } })
       && { registerClassFile(className, path), true } }
}

_search(relpath :String) :String
{
  let result = tycoon.os.fs.search(tl2Path, relpath),
  (* tycoon.stdout.writeln(relpath+" => "+result.printString), *)
  result
}

tl2Path :String
{
  let result = tycoon.ansiC.getenv("TL2_PATH"),
  result.isNotNil
  ? { result }
  : { tycoon.os.fs.currentPath }
}

parseNewFiles
{
  classManager.classTable.do(fun(cl :ClassPublic) {
    let relPath = cl.pos.where,
    relPath != "<stdin>" && { relPath != "<string>" }
    ? { (* class comes from a file. *)
        let resolvedPath = _search(relPath),
        resolvedPath.isNotNil
	? { needsReload(cl, resolvedPath)
	    ? { parseFile(cl.name, relPath, resolvedPath) } }
	: { errorLog.warning(SourcePos.new(relPath,0,0),
			     "Cannot find file for class "+cl.name+" in "+tl2Path) } }
  })
}

needsReload(cl :ClassPublic, resolvedPath :String) :Bool
{
  let currentSourceTime = pathLastModified(resolvedPath),
  currentSourceTime.isNotNil
  ? { (cl.sourceTime.isNil || { currentSourceTime != cl.sourceTime })
      ? { (* version on disk is younger (or older(?)) than compiled version *)
	  let currentFingerPrint = MD5.file(resolvedPath),
	  currentFingerPrint != cl.fingerPrint
	  ? { (* version on disk differs from compiled version (or no fingerprint) *)
	      builders.lookup(cl.name, fun(b :ClassBuilder) {
		b.pos.where != cl.pos.where
		? { (* ouch: builder comes from different file. *)
		    errorLog.warning(cl.pos, "(3) class "+cl.name+" moved from "+b.pos.where+" to "+cl.pos.where),
		    b.pos := cl.pos },
		currentFingerPrint != b.fingerPrint
		? { builders.removeKey(cl.name),	     (* builder is out of date *)
		    true  }
		: { false (* builder needs to be started *) }
	      },
	      { true (* no builder *) }) }
	  : { (* version on disc is unchanged *)
	      tycoon.stdout << "class " << cl.name << " not modified\n",
	      cl.sourceTime := currentSourceTime,  (* no need to compute fingerprint next time *)
	      false} }
	: { false (* compiled version is up to date *) } }
  : { errorLog.warning(SourcePos.new(resolvedPath,0,0), "Cannot access file for class "+cl.name),
      false }
}

pathLastModified(path :String) :Long
{
  let f = File.new(path),
  try({
    f.lastModified
  }, fun(:Exception){
    nil
  })
}

(* try to parse file <path> and add a ClassBuilder for it to <self.builders> *)
parseFile(expectedName :String, relPath :String, resolvedPath :String)
{
  tycoon.stdout.writeln("["+relPath),
  let var getPosition :Fun0(SourcePos) =
    { SourcePos.new(relPath,-1,-1) },
  try({
    let f = File.openRead(resolvedPath),
    let time = f.lastModified,
    let md5 = MD5.new,
    let input = FunInput.new(
      fun(buffer :MutableString, start :Int, n :Int) :Int {
        let nRead = f.readBuffer(buffer, start, n),
	md5.updateSubString(buffer, start, nRead),
	nRead
      }),

    try({
      let tokenStream = scanner.scan1(relPath, input, errorLog, let bufferCapacity = 1024),
      getPosition := { tokenStream.userState.position },

      let parseUnit =
        parser.parse(tokenStream,
	  fun(tok :Token(Object)) {
	    errorLog.error(getPosition[], "parse error on "+tok.printString)
	  }),

      let node =
	parseUnit.isNotNil ? { parseUnit.asClassBuilder } : { nil },
      node.isNotNil
      ? { node.normalize,
	  node.sourceTime := time,
	  node.fingerPrint := md5.final,

	  node.name != expectedName
	  ? { (* ### maybe refuse the file? *)
	      errorLog.warning(node.pos, "expected class "+expectedName+", found "+node.name) },

	  (* check for existing class / builder with that name *)
	  builders.lookup(node.name, fun(b :ClassBuilder) {
	    errorLog.warning(node.pos, "(1) class "+node.name+" moved from "+b.pos.where+" to "+relPath)
	  }, {
	    classManager.classTable.lookup(node.name, fun(cl :ClassPublic) {
	      cl.pos.where != relPath
	      ? { errorLog.warning(node.pos, "(2) class "+node.name+" moved from "+cl.pos.where+" to "+relPath) }
	    }, { (* aok *) })
	  }),

	  builders[node.name] := node },
      nil
    }, fun(e:Exception){
      errorLog.error(getPosition[], "Exception: "+e.printString),
      nil
    }),

    !md5.isFinalized ? { md5.final },  (* free C structure (### one day, use CStructs) *)
    f.close
  }, fun(e:Exception) {
    errorLog.error(getPosition[], "Could not open: "+e.printString)
  }),
  tycoon.stdout.writeln("]")
}

checkUnknown
{
  builders.do(fun(n:ClassBuilder) {
    checkUnknown1(n.metaClassDeclaration),
    n.supers.do(fun(cplType :CPLType) {
      checkUnknown1(cplType)
    })
  })
}

checkUnknown1(cplType :CPLType)
{
  let name = cplType.ide.name,
  !builders.includesKey(name)
  && { !classManager.classTable.includesKey(name) }
  ? { errorLog.error(cplType.pos, "unknown class name: "+name) }
}

makeClasses
{
  try({
    (* another depth first numbering... *)
    let visited = Set(:ClassState).new,
    let busy = EmptyList.new,
    classManager.classTable.do(fun(c:ClassState) {
      makeByName(c.name, visited, busy)
    })
  }, fun(e:Exception){
    (* ignore ErrorLogError *)
    e."class" !== ErrorLogError
    ? { e.raise }
  })
}

ensureDependencies(c :ClassState, visited :Set(ClassState), busy :List(ClassState))
{
  !visited.includes(c) ? {
    busy.includes(c) ? {
      !List.with4("MetaClass", "ConcreteClass", "AbstractClass", "Class").includes(c.name)
      ? { tycoon.stdout.writeln("Circular relationship in class "+c.name),
	  let r = busy.reader,
	  let var red :ClassState = nil,
	  while({(red := r.read).isNotNil && { red !== c }},{
	    tycoon.stdout.writeln(" needed by "+red.name)
	  }),
	  tycoon.stdout.writeln(" needed by "+c.name) }
    } : {
      let busy = List.cons(c, busy),
      makeByName(c.metaClassDeclaration.ide.name, visited, busy),
      c.supers.map(fun(t :CPLType){ t.ide.name }).do(fun(str :String) {
	makeByName(str, visited, busy)
      })
    }
  }
}

makeByName(name :String, visited :Set(ClassState), busy :List(ClassState))
{
  (* tycoon.stdout.writeln("{"+name), *)
  builders.lookup(name, fun(c:ClassBuilder) {
    ensureDependencies(c, visited, busy),
    builders.includesKey(name)   (* might have disappeared due to recursion *)
    ? { builders.removeKey(name),  (* the builder is spoiled by executing it *)
        c.build(compiler, classManager, errorLog),
        errorLog.raiseError } (* ### a bit harsh maybe? *)
  }, {
    ensureDependencies(classManager.classTable[name], visited, busy)
  }),
  (* tycoon.stdout.writeln("}"), *)
  visited.add(classManager.classTable[name])
}

_init :Self
{ super._init,
  builders := Dictionary.new,
  errorLog := ErrorLog.new,
  self
}
;

