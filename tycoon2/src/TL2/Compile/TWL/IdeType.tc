class IdeType 
  super TypeImpl, LeafMixin
  metaclass IdeTypeClass

public
  ide :TypeIde,
  age :Int   

methods

  visit(T <: Void, visitor :TypeVisitor(T)) :T { visitor.visitIdeType(self) }
  

  reduce(T <: Void, s :Subst, cont: Fun2(Type, Subst, T)) :T
  {
    s.subst(ide,
      { cont[self, EmptySubst.instance] },
      fun(t :Type, s :Subst) { t.reduce(s, cont) }
    )
  }
  

  
  (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 default: maybe substitute self
		      or
	      strip self and check result <: big
	      subtype trans: T <:X, X <:Y => T <:Y
  *)
  defaultCheckSubType(big :Type, subst :Subst, bigSubst :Subst) {
    subst.subst(ide, {
		(* ## is it ok to drop subst ???
		   ## my brain''s mangled about that
		*)
		ide.type.checkSubType(big, EmptySubst.instance, bigSubst)
		},
		fun(small :Type, smallSubst :Subst) {
		  small.checkSubType(big, smallSubst, bigSubst)
		})
  }

  checkSubNilType   (big :NilType,    subst :Subst, bigSubst :Subst) { defaultCheckSubType(big, subst, bigSubst) }
  checkSubObjectType(big :ObjectType, subst :Subst, bigSubst :Subst) { defaultCheckSubType(big, subst, bigSubst) }
  checkSubApplyType (big :ApplyType,  subst :Subst, bigSubst :Subst) { defaultCheckSubType(big, subst, bigSubst) }

  checkSubOperType  (big :OperType,   subst :Subst, bigSubst :Subst) { defaultCheckSubType(big, subst, bigSubst) }
  checkSubSubstType (big :SubstType,  subst :Subst, bigSubst :Subst) {
    checkSubType(big.type, subst, CompositeSubst.new(big.substi, bigSubst))
  }


  checkSubIdeType   (big :IdeType,    subst :Subst, bigSubst :Subst)
  {
    (ide == big.ide) && { (subst == bigSubst) } ? {
      (* Subtype refl *)
    } : {
    subst == EmptySubst.instance && { bigSubst == EmptySubst.instance } ? {
      (* The real Sub Ide *)
      !big.ide.isSubTypeIde ? {
        (* BIG = SomeOther *)
	checkSubType(big.ide.type, subst, bigSubst)
      } : {
        ide.type.checkSubType(big, subst, bigSubst)
      }
    } : {
      (*
			  1. substitute self
	 if not possible: 2. substitute big
	 if not possible: 3. strip small
      *)
      
      subst.subst(ide, {
		  let subst = EmptySubst.instance,
		  bigSubst.subst(big.ide, {
				 let bigSubst = EmptySubst.instance,
				 checkSubType(big, subst, bigSubst)
				 },
				 fun(big :Type, bigSubst :Subst) {
				   checkSubType(big, subst, bigSubst)
				 })
		  },
		  fun(small :Type, smallSubst :Subst) {
		    small.checkSubType(big, smallSubst, bigSubst)
		  })

    }}
  }

  checkSubUnifyType (big :UnifyType,  subst :Subst, bigSubst :Subst)
  {
    subst.subst(ide,
		{
		  let subst = EmptySubst.instance,
		  big.instantiateSuper(self, subst)
		},
		fun(t :Type, subst :Subst) {
		  t.checkSubType(big, subst, bigSubst)
		}
	       )
  }



  prettyPrint(out :Printer)
  {
    printIdeOn(ide, out)
(*    out.writeAll("["+ide.identityHash.printString+"]") *)
  }

  scope(env :Scoper) :IdeType
  {
    ide := env.scope(ide),
    (* ### age *)
    self
  }

  subst(subst :Subst) :Type
  {
    subst.subst(ide, fun() :Type { self }, fun(t :Type, s :Subst) {
      t.subst(s)
    })
  }

  charCode :Char
  { genericCharCode(
      Array.with6( "Bool", "Char", "Int", "Int32", "Long",
		   "Real"))
  }

  resultCharCode :Char
  { genericCharCode(
      Array.with8( "Bool", "Char", "Int", "Int32", "Long",
		   "Real", "String", "MutableString"))
  }


private methods

  genericCharCode(codes :Array(String)) :Char
  {
    codes.includes(ide.name)
    ? { ide.name[0] }
    : { 'O' }
(* (* ### check for locally bound identifiers disabled (which typeManager to use?) *)
    let ide = ide,
    let typeManager = tycoon.tl.typeManager,
    typeManager.isDefined(ide.name) && { typeManager.signature(ide.name) == ide }
    ? { codes.includes(ide.name)
	? { ide.name[0] }
	: { 'O' }}
    : { (* ide is locally bound *)
	nil }
 *)
  }

  doExpose(T <: Void, subst :Subst, exact :Bool, cont :Fun2(Type, Subst, T)) :T
  {
    subst.subst(self.ide, {
      exact && { ide.isSubTypeIde } ? fun() :T {
        raiseError
      } : {
        cont[ide.type, EmptySubst.instance]
      }
    }, fun(substituted :Type, subst :Subst) {
      substituted.expose(subst, exact, cont)
    })
  }
  
;


