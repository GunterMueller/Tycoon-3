class SubstType 
(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 Apply subst on type (compose current substitution with subst,
   i.e. apply subst before current substitution).  *)
  super TypeImpl
  metaclass SubstTypeClass

public
  type :Type,
  substi :Subst   (* conflict with Type.subst *)

methods

  visit(T <: Void, visitor :TypeVisitor(T)) :T
  {
    visitor.visitSubstType(self)
  }

  reduce(T <: Void, subst :Subst, cont :Fun2(Type, Subst, T)) :T {
    type.reduce(CompositeSubst.new(substi, subst), cont)
  }

  prettyPrint(o :Output) {
    o << "(" << type << substi << ")"
  }

  (* these perform the actual subtype tests; now both types are known
     call from checkSuperType --- double dispatch
  *)
  checkSubNilType   (big :NilType,    subst :Subst, bigSubst :Subst) { checkSubAnyType(big, subst, bigSubst) }
  checkSubObjectType(big :ObjectType, subst :Subst, bigSubst :Subst) { checkSubAnyType(big, subst, bigSubst) }
  checkSubApplyType (big :ApplyType,  subst :Subst, bigSubst :Subst) { checkSubAnyType(big, subst, bigSubst) }
  checkSubIdeType   (big :IdeType,    subst :Subst, bigSubst :Subst) { checkSubAnyType(big, subst, bigSubst) }
  checkSubUnifyType (big :UnifyType,  subst :Subst, bigSubst :Subst) { checkSubAnyType(big, subst, bigSubst) }
  checkSubOperType  (big :OperType,   subst :Subst, bigSubst :Subst) { checkSubAnyType(big, subst, bigSubst) }
  checkSubMethodType(big :MethodType, subst :Subst, bigSubst :Subst) { checkSubAnyType(big, subst, bigSubst) }

  (* unwind the SubstType
     we may NOT use expose so we don''t skip an Ide
  *)
  checkSubAnyType(big :Type, subst :Subst, bigSubst :Subst)
  {
    type.checkSubType(big, CompositeSubst.new(self.substi, subst), bigSubst)
  }

private methods

  (* which order ? substi,subst OR subst,substi ? *)
  doExpose(T <: Void, subst :Subst, exact :Bool, cont :Fun2(Type, Subst, T)) :T
  {
    type.expose(CompositeSubst.new(self.substi, subst), exact, cont)
  }
  
;


