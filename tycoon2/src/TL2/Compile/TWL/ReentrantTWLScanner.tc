class ReentrantTWLScanner
super TWL
metaclass ReentrantTWLScannerClass
public methods

scan(where :String, input :Input, errorLog :ErrorLog (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
, bufferCapacity :=100*)) :TWLScanner
{ scan1(where, input, errorLog, 100) }

scan1(where :String, input :Input, errorLog :ErrorLog, bufferCapacity :Int) :TWLScanner
{
  let s =
    UserScanner.new1(tables, input, let bufferCapacity = bufferCapacity,
      TWLScannerState.new(twlTerminals.keywords, where, errorLog)),
  s.errorHandler :=   (* ### should become an argument when optional parameters are available *)
    fun(ch :Char){ s.userState.error(ch) },
  s.userState.scanner := s,  (* backward reference for source positions *)
  s
}

private

twlTerminals :TWLTerminals,

tables :UserScannerTables(Token(Object), TWLScannerState),

escapes :Dictionary(Char, Char)

methods

_init :Self
{ super._init,

  (* add regexps for twlTerminals standard terminal symbols *)

  let ident = twlTerminals.ident,
  let string = twlTerminals.string,
  let char = twlTerminals.char,
  let int = twlTerminals.int,
  let real = twlTerminals.real,

  escapes := Dictionary.new,
  escapes['n'] := '\n',
  escapes['t'] := '\t',
  escapes['r'] := '\r',
  escapes['f'] := '\f',
  escapes['\''] := '\'',
  escapes['\"'] := '\"',
  escapes['\\'] := '\\',

  let digit = "[0-9]",
  let alpha = "[a-zA-Z_]",
  let special = "[!#$%&*+-/:;<=>?@^`|~]",
  let simpleEscape = quoteRE(String.fromReader(escapes.keys)),  (* for '\\' *)
  let escape = "\\\\(["+simpleEscape+"]|"+digit+digit+digit+")",
  let delimiter = "([()\\{\\}.,]|\\[|\\])",

  let digits = digit+"+",
  let idRegExp = alpha+"("+alpha+"|"+digit+")*",

  let sb = EagerScannerBuilder(:Token(Object), :TWLScannerState).new,
  
  sb.addToken("\"(" + digit +
		"|" + alpha +
		"|" + special +
		"|" + escape +
		"|" + delimiter + "| )*\"",
    fun(s :TWLScanner) {
      let r = s.token.subSequenceReader(1,s.tokenSize-2),
      string.token(Positioned.new(s.userState.position,
        String.fromReader(FunReader.new({ decodeChar(r) }))
      ))
    }
  ),

  sb.addToken("\'(" + digit +
		"|" + alpha +
		"|" + special +
		"|" + escape +
		"|" + delimiter + "| )\'",
    fun(s :TWLScanner) {
      char.token(Positioned.new(s.userState.position,
        decodeChar(s.token.subSequenceReader(1,s.tokenSize-2))
      ))
    }
  ),


  sb.addToken(digits,
    fun(s :TWLScanner) {
      int.token(Positioned.new(s.userState.position,
        s.token.asInt	    (* ### better? *) (* Int.fromReader(s.tokenReader) *)
      ))
    }
  ),

  let realAction =
    fun(s :TWLScanner) {
      real.token(Positioned.new(s.userState.position,
        s.token.asReal
      ))
    },
  sb.addToken(digits+"."+digits, realAction),
  sb.addToken(digits+"(."+digits+")?(E|e)(+|-)?"+digits, realAction),

  sb.addToken("[ \t\r\f]+",
    fun(s :TWLScanner) {
      s.read
    }
  ),

  sb.addToken("\n",
    fun(s :TWLScanner) {
      s.userState.newline,
      s.read
    }
  ),

  sb.addToken(";",
    fun(s :TWLScanner) {
      nil
    }
  ),

  let commentMode = sb.newMode,
  
  sb.addToken("\\(\\*",
    fun(s :TWLScanner) {
      s.mode := commentMode,
      s.userState.nesting := 1,
      s.readAppend
    }
  ),

  sb.addTokenMode(commentMode, "[^\n]", fun(s:TWLScanner) {
    s.read
  }),
  sb.addTokenMode(commentMode, "\n", fun(s:TWLScanner) {
    s.userState.newline,
    s.read
  }),
  sb.addTokenMode(commentMode, "\\(\\*", fun(s:TWLScanner) {
    s.userState.nesting := s.userState.nesting + 1,
    s.read
  }),
  sb.addTokenMode(commentMode, "\\*\\)", fun(s:TWLScanner) {
    s.userState.nesting := s.userState.nesting -1,
    s.userState.nesting = 0 ? { s.mode := 0 },
    s.read
  }),

  sb.addToken(idRegExp, fun(s:TWLScanner) {
    s.userState.identify(ident)
  }),

  (* add regexps for symbols *)

  twlTerminals.symbols.keysAndElementsDo(
    fun(name: String, term :ValueTerminal(SourcePos)) {
      sb.addToken(quoteRE(name), fun(s:TWLScanner) {
        term.token(s.userState.position)
      })
    }
  ),

  (* ... and go *)
  tables := sb.generate,

  self
}

decodeChar(r :Reader(Char)) :Char
{
  let c = r.read,
  c.isNil || { c !== '\\' } ? {
    c
  } : {
    let c = r.read,
    escapes.lookup(c,
      fun(coded :Char) {
        coded
      },
      { 
        assert c.isDigit,
	let i = c.digitValue,
	let c = r.read,
	assert c.isNotNil & c.isDigit,
	let i = i * 10 + c.digitValue,
	let c = r.read,
	assert c.isNotNil & c.isDigit,
	let i = i * 10 + c.digitValue,
	i.asChar
      }
    )
  }
}

(* ### what a hack! *)
quoteRE(s :String) :String
{
  let qs = MutableString.new(s.size * 2),
  for(0, s.size-1, fun(i :Int) {
    qs[2*i] := '\\',
    qs[2*i+1] := s[i]
  }),
  qs
}
;


