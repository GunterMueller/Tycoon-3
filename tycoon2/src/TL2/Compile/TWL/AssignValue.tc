class AssignValue
super Value
metaclass AssignValueClass
public
lhs :ValueIde,
rhs :Value

methods

prettyPrint(out :Printer)
{
  printIdeOn(lhs, out),
  out.writeAll(" := "),
  rhs.isSimple ? {
    rhs.prettyPrint(out)
  } : {
    out.withRelIndent(2, {
      out.nl,
      rhs.prettyPrint(out)
    })
  }
}

children :Reader(Value)
{
  Reader.with1(rhs) 
}




scope(env :Scoper) :Value
{
  rhs := env.scope(rhs),
  let scopedLhs = env.scope(lhs),
  scopedLhs.isNil ? {
    (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 lhs ide is not in local scope => implicit self message *)
    let selfSig = env.selfSig,
    selfSig.isNotNil ? fun() :Value {
      SendValue.new1( pos,
		      IdeValue.new(selfSig),
		      Symbol.new(lhs.name + ":="),
		      List.with1(rhs))
    } : {
      env.errorLog.error(pos, "unbound identifier: self (while scoping "+lhs.name+")"),
      rhs
    }
  } : {
    lhs := scopedLhs,
    !lhs.mutable
    ? { env.errorLog.error(pos, "assignment to immutable variable"),
        env.errorLog.error(lhs.pos, "(definition of "+lhs.name+")"),
	rhs }
    : { lhs.setAssigned,
        self }
  }
}    

genCode(backEnd :MethodManager)
{ rhs.genCode(backEnd),
  backEnd.store(lhs)
}

private methods

  doCheck(T <: Void, cont :Fun2(Type, Subst, T)) :T
  {
    lhs.mutable ? {
      rhs.check(fun(rhsType :Type, rhsSubst :Subst) {
        setError(pos, "Attempt to assign value of wrong type", {
	  rhsType.checkSubType(lhs.type, rhsSubst, EmptySubst.instance)
	}),
	cont[rhsType, rhsSubst]
      })
    } : {
      setError(pos, "Attempt to assign to immutable var", {
        raiseError
      })
    }
  }

;





