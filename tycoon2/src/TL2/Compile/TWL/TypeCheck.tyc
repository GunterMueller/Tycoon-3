tycoon.tl.loader.registerDirectory("../TWL/Compile/TWL");

(* All defines can be :Void since we are in Smalltalk-mode now :-*)

define newTypeIde :Void;
newTypeIde := fun(name :String, type :Type) { TypeIde.new1(nil, name, type) };

define newSubTypeIde :Void;
newSubTypeIde := fun(name :String, type :Type) { SubTypeIde.new1(nil, name, type) };

define newIdeType :Void;
newIdeType := fun(ide :TypeIde) { IdeType.new(ide) };

define printTS :Void;
printTS := fun(t :Type, s :Subst) { t.print, s.print, tycoon.stdout.nl };

define N :Void;
N := NilType.instance;

define es :Void;
es := EmptySubst.instance;

define V :Void;
V := VoidType.instance;

(* T <: Void *)
define T_ide :Void; define T :Void;
T_ide := newSubTypeIde["T", V];
T := newIdeType[T_ide];

(* The identity TypeOp: \-/ X<:Void . X *)
define IO :Void;
IO := { let X = newSubTypeIde["X", V], OperType.new(List.with1(X), newIdeType[X]) }[];

IO.apply(List.with1(T), es, es, false, fun(type :Type, subst :Subst) { type.print, subst.print, tycoon.stdout.nl });

(* something nice with F-Bound *)
define NO :Void;
NO := {
  (* T <: IO(T) *)
  let T = newSubTypeIde["T", N],
  T.type := ApplyType.new(IO, List.with1(newIdeType[T])),

  (* U <: T *)
  let U = newSubTypeIde["U", newIdeType[T]],

  OperType.new(List.with2(T, U), ApplyType.new(IO, List.with1(newIdeType[U])))
}[];



define typify :Fun0(Void);
let giveType = fun(c :Class) {
  c.typeIde.type := c.domain.isEmpty ? {
    ClassInstanceType.new(c)
  } : {
    OperType.new(c.domain, ClassInstanceType.new(c))
  }},

typify := {
    tycoon.tl.classManager.classTable.do(fun(c :Class) { giveType[c] })
  }
;



let t = ApplyType.new(Dictionary.typeIde.type, List.with2(String.typeIde.type, Int.typeIde.type)), let s = Symbol.new("includes"), for(1, 1000, fun(:Int) { t.lookup(s, es, fun(:Type, :Subst) {}) });

ApplyType.new(Dictionary.typeIde.type,
	      List.with2(String.typeIde.type, Int.typeIde.type)).
	        expose(es, true, fun(t :Type, subst :Subst) {
		   let s = Symbol.new("includes"), t.lookup(s, subst, printTS)
		});
		
ApplyType.new(List.typeIde.type,
	      List.with1(String.typeIde.type)).
	        lookup(Symbol.new("tail"), es, printTS

		(* fun(:Type, s :Subst) {

	           IdeType.new(AbstractList.typeIde.type.domain[0]).expose(s, true, printTS)
		} *)
);


		
class A(PA <: Object) metaclass AbstractClass public methods a :A(Int) deferred;

class M super A(Char) metaclass AbstractClass;
class N super M metaclass AbstractClass;

typify[];

IdeType.new(N.typeIde).checkSubType(IdeType.new(M.typeIde), es, es);


IdeType.new(B.typeIde).checkSubType(IdeType.new(A.typeIde), es, es);

class D metaclass AbstractClass public methods d :String deferred;
class E metaclass AbstractClass public methods d :Void deferred;

IdeType.new(D.typeIde).checkSubType(IdeType.new(E.typeIde), es, es);

class F metaclass AbstractClass public methods m :Self deferred;
class G metaclass AbstractClass public methods m :Self deferred   g :G deferred;

typify[];

IdeType.new(G.typeIde).checkSubType(IdeType.new(F.typeIde), es, es);

IdeType.new(Symbol.typeIde).checkSubType(IdeType.new(String.typeIde), es, es);

(* B(String) <: A(String) *)

ApplyType.new(IdeType.new(List.typeIde),
	      List.with1(IdeType.new(Symbol.typeIde))).
checkSubType(
  ApplyType.new(IdeType.new(List.typeIde),
	        List.with1(IdeType.new(String.typeIde))),
  es,
  es);
  
ApplyType.new(IdeType.new(List.typeIde),
	      List.with1(IdeType.new(String.typeIde))).
checkSubType(
  ApplyType.new(IdeType.new(List.typeIde),
	        List.with1(IdeType.new(Symbol.typeIde))),
  es,
  es);
  
	      

	        lookup(Symbol.new("yourself"), es, fun(t :Type, s :Subst) {
		  printTS[t, s],
		  IdeType.new(Object.selfTypeSig).expose(s, false, printTS)
		}
);

let theSelf = IdeType.new(List.typeIde.type.range.selfTypeSig),
let theSubst = ConsSubst.new(List.typeIde.type.domain[0], IdeType.new(String.typeIde), EmptySubst.instance),
theSelf.lookup(Symbol.new("head"), theSubst, fun(t :Method, s :Subst) { t.methodType.range.expose(s, false, printTS) });



define stdinValue :Void;
stdinValue := { tycoon.tl.topLevel.parser.parse(tycoon.tl.topLevel.scanner.scan(nil, tycoon.stdin, nil), nil).b };






define fixPoolMethods :Void;
fixPoolMethods := {
  let s = Scoper.new,
  s.currentClassSig := tycoon.tl.classManager.get("Nil").typeIde,
  
  tycoon.tl.pool.poolMethods.do(fun(pm :Method) {
    pm.methodType := s.scope(pm.methodType)
  })
};

define fixSlotUpdateMethods :Void;
fixSlotUpdateMethods := {
    tycoon.tl.classManager.classTable.do(fun(c :Class) {
      c.methodDictionaries.do(fun(dict :MethodDictionary) {
        dict.do(fun(m :Method) {
	  m."class" == SlotUpdateMethod ? {
	    m.methodType.range := m.slotType    
	  }
	})
      })
    })
  }
;

define errors :StringBuilderOutput;
define checkAllClasses :Void;
checkAllClasses := {
    errors := StringBuilderOutput.new,
    
    tycoon.tl.classManager.classTable.do(fun(c :Class) {
      try({
        checkClass[c]
      }, fun(e :Exception) { errors.writeln(e.printString) })
    })
  }
;

define inspectDB :Void;
inspectDB := {
 tycoon.tl.typeManager.typeChecker.subTypeDB._elements.do(fun(e :Void) { tycoon.stdout.write(e.isNil ? {'.'} : {'X'}) })
};

(* in LetValueClass ? *)
define _replaceUnifyTypeVisitor :Void;
_replaceUnifyTypeVisitor :=
  FunTypeVisitor.new.
    ifUnifyType(fun(:UnifyType) { UnifyType.new }).
    otherwise(fun(t :Type) { t });


define _storeTypeVisitor :Void;
define _typeHashVisitor :Void;
define _equalTypesVisitor :Void;

define fixSelfIdes :Void;
fixSelfIdes := {
    tycoon.tl.classManager.classTable.do(fun(c :Class) {
      c.methodDictionary.do(fun(m :Method) {
        m."class" == CompiledMethod ? {
	  fixSelfIdesInValue[c, m.body]
	}
      })
    })
  }
;

define fixSelfIdesInValue :Void;
fixSelfIdesInValue := fun(c :Class, v :Value) {
  v."class" == IdeValue ? {
    v.ide.name = "self" ? {
      v.ide.type := IdeType.new(c.selfTypeSig)
    }
  },

  v.children.do(fun(v :Value) { fixSelfIdesInValue[c, v] })
};

Thread.new({
let errors = File.openWrite("typeCheckErrors.txt"),
tycoon.tl.classManager.classTable.do(fun(c :Class) { try({ tycoon.tl.typeManager.checkClass(c) }, fun(e :Exception) { errors << e << "\n" }) }),
errors.close
});




Root.instance.classes.do(fun(c :Class) {
  tycoon.stdout << "Rescoping " << c.name << "\n",
  let s = Scoper.new,
  s.currentClassSig := c.typeIde,
  s.errorLog := ErrorLog.new,
  s.withScopedSignatures(c.domain, {
    s.withSignature(c.selfTypeSig, {
      let slf = ValueIde.new1(c.selfTypeSig.pos, "self", IdeType.new(c.selfTypeSig)),
      s.withSignature(slf, {
        s.do(fun(i :Ide) { tycoon.stdout << i }),
	c.methodDictionary.do(fun(m :Method) {
	  m.scopeMethod(s)
	})
      })
    })
  })
});

let s = Scoper.new,
s.currentClassSig := tycoon.tl.classManager.get("Nil").typeIde,
s.errorLog := ErrorLog.new,
Pool.instance.poolMethods.do(fun(m :Method) { m.scopeMethod(s) })
;

class MyAppend super Object metaclass AbstractClass
public methods
  myAppend { let l :List(Int) = List.with1(3), List.append(l, List.with1(10)) }
;
