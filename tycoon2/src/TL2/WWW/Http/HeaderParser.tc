(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *

  Parsing MIME headers
  Author: Matthias Ernst 12/96
  Change: me 6.1.96 Names
*)

class HeaderParser
super Http
metaclass HeaderParserClass

public

in :Reader(Char)

methods


parseHeaders: MimeHeaderDictionary(MimeHeaderValue)
{
  let result = MimeHeaderDictionary(:MimeHeaderValue).new,
  let parser = MimeParser.new(in),
  
  while({
    (* Empty line ends headers
       should be CRLF but we allow LF only too *)
    !(parser.char == '\n' || {
      parser.char == '\r' && { parser.next, parser.char == '\n' }
    })
  }, {
    let name = headerName(parser),
    parser.skip(':'),
    let value = headerValue(parser),

    (* Lookup (or enter) headerValue *)
    let var headerValue = result.lookup(name,
      let ifFound    = fun(hv: MimeHeaderValue) { hv },
      let ifNotFound =                          { result[name] := newHeaderValue(name) }
    ),

    (* if this header already exists, we should build a list from the values.
       should this be a special behaviour of the 'string:=' message, or should
       the knowledge be here ?
    *)
    headerValue.string := value
  }),

  result
}

private methods

newHeaderValue(name :String) :MimeHeaderValue
{
  MimeHeaderRegistry.instance.newHeaderValue(name)
}

headerName(parser :MimeParser) :String {
  parser.nextToken
}

headerValue(parser :MimeParser) :String {
  parser.skiphws,
  let value = GapString.new(10),
  
  let var break = false,
  while({!break}, {
    parser.char == nil ? { MimeParserError.new("Premature end of headers").raise },

    parser.char == '\n' || { parser.char == '\r' && { parser.next, parser.char == '\n' }} ? {
	 parser.next,
	 parser.char != ' ' && { parser.char != '\t' } ? {
	   break := true, nil
	 } : {
	   parser.skiphws,
	   value.add(' '), nil   (* LWS is equivalent to SP *)
	 }
    } : {
      value.add(parser.char),
      parser.next,

      nil
    }
  }),

  value.asString
}

;
