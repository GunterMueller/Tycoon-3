class HttpDirectoryResource

super HttpContainerResource

public

methods

contents :DirectoryContents
{
  dir
}

reindex
  (*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 forget any automatically indexed child resources
     re-index at subsequent requests.
     But keep directory resources, propagate reindex down
     the directory tree.
  *)
{
  let old = _children,
  _children := _virtuals.copy,
  old.keysAndElementsDo(fun(name :String, resource :HttpResource) {
    resource.asDirectoryResource.isNotNil ? {
      _children[name] := resource
    },
    resource.reindex
  }),
  _modified
}

replace(old :HttpResource, new :HttpResource)
{
  let key = _children.locate(old),
  _children[key] := new,
  
  let key = _virtuals.locate(old),
  key.isNotNil ? {
    _virtuals[key] := new
  },

  new.parent := self,
  old.parent := nil	       
}

asDirectoryResource :HttpDirectoryResource
{
  self
}

"[]"(name :String) :HttpResource
{
  validate,
  _children[name]
}

"[]:="(name :String, resource :HttpResource) :HttpResource
{
  _modified,
  resource.parent := self,
   _virtuals[name] := _children[name] := resource
}

removeKey(name :String)
{
  _virtuals.removeKey(name),
  _children.removeKey(name),
  _modified
}

reader :Reader(HttpResource)
{
  validate,
  _children.reader
}

keys :Reader(String)
{
  validate,
  _children.keys
}

resourceFactory :HttpResourceFactory
  (* answer the resource factory defined for this directory.
     an resource factory may be configured explicitely by storing an resource factory
     object within the receiver, or implicitely by the next parent directory. *)
{
   _resourceFactory
}

"resourceFactory:="(resourceFactory :HttpResourceFactory) :HttpResourceFactory
  (* configure the receiver with the given resource factory *)
{
  _resourceFactory := resourceFactory,
  reindex,
  resourceFactory
}


validate :Void
  (* validate any cached information. default: do nothing *)
{
  _stamp < _dir.lastModified ? {
    _stamp := _dir.lastModified,
    _sync
  }
}

urlPath(request :HttpRequest) :String
{
  let uri = request.uri,
  let var i = uri.locateChar(':'),
  i.isNil ? { i := -1 },
  let path = uri.subString(i+1,uri.size-(i+1)),
  path.size = 0 || {path[path.size-1] != '/'}
    ? { path + "/" }
    : { path }
  }


get(request :HttpRequest) :HttpResponse
{
  let dirPath = urlPath(request),
  let title = "Index of " + dirPath, 
  let response = newResponse(HttpResponse.OK),
  response.withHtmlGenerator(fun(out :HtmlGenerator) {
    out.title({ out.writeString(title) }), 
    out.body({
        out.h1({ out.writeString(title) }), 
        out.table(false, {
        (* out.th("CENTER", 4, 1, { out.writeString(title) }), *)
	out.tr({
  	  out.td("LEFT", 1, 1, { }), 
  	  out.td("LEFT", 1, 1, { out.b({out.writeln("Name") })}),
  	  out.td("LEFT", 1, 1, { out.b({out.writeln("Last modified") })}),
  	  out.td("LEFT", 1, 1, { out.b({out.writeln("Size") })})
	}),
	
	let parentUrl = parentUrl(dirPath),
	parentUrl.isNotNil ? {
	  out.tr({
	    let icon = "/hox-icons/back.gif",
	    out.td("LEFT", 1, 1, {
	      out.a(parentUrl, nil, {
	        out.img(icon,"LEFT", "\" \"", 0, false, false) 
	      })
	    }),
	    out.td("LEFT", 1, 1, {
	      out.a(parentUrl, nil, {
	        out.writeString("Parent Directory")
	      }),
	    out.nl
	    })
	  })
	},
	let keys = MutableArray.fromReader(keys),
	keys.quicksort(fun(s1 :String, s2 :String) { s1.order(s2) }),
	keys.do(fun(name :String) {
	  let resource = self[name],
	  out.tr({
	    let icon = resource.icon,
	    let cl = resource.contentLength,
	    let cls = cl.isNotNil ? { cl.printString } : { "" },
	    let lm = resource.lastModified,
	    let fmt = "%d-%b-%y %H:%M",
	    let lms = cl.isNotNil ? {  Date.fromTime(lm).format(fmt) } : { "" },
	    let url = dirPath + name,
	    
	    out.td("LEFT", 1, 1, {
	      out.a(url, nil, {
	        out.img(icon,"LEFT", "\" \"", 0, false, false) 
	      })
	    }),
	    out.td("LEFT", 1, 1, {
	      out.a(url, nil, {
	        out.writeString(name)
	      })
	    }),
	    out.td("LEFT", 1, 1, { out.writeln(lms) }),
	    out.td("LEFT", 1, 1, { out.writeln(cls) }),
	    out.nl
	  })    
	})
      })
    })
  }),
  response
}

newResource(dir :Directory, name :String) :HttpResource
  {
  resourceFactory.isNotNil
    ? { let resource = resourceFactory.newResource(dir, name),
        resource.isNil
	   ? { super.newResource(dir, name) }
	   : { resource.parent := self,
	       resource
	     }
      }
    : { super.newResource(dir, name)}
  }


printOn(out :Output)
  {
  out.writeln("HttpDirectoryResource{"),
  let keys = keys,
  keys.do(fun(name :String){ out.writeln(name) }),
  out.writeln("}")
  }

dir :Directory
{
  _dir
}


"dir:="(dir :Directory) :Directory
{
  _stamp := Long.MIN_VALUE,
  _dir := dir
}

private

_dir :Directory,
_resourceFactory :HttpResourceFactory,
_stamp :Long,
_children :Dictionary(String, HttpResource),  (* all accessible child resources *)
_virtuals :Dictionary(String, HttpResource)   (* explicitely added 'virtual' resources (no File equivalent) *)


methods

_init :Void
{
  super._init,
  _virtuals := Dictionary.new,
  _children := Dictionary.new,
  icon := "/hox-icons/folder.gif",
  _stamp := Long.MIN_VALUE,
  self
}

_sync :Void
  (* we got out of sync. re-load child resources. *)
{
  let old = _children,
  _children := _virtuals.copy,
  let keys = _dir.keys,
  keys.do(fun(name :String) {
    try(fun() :Void{
      let resource = old.lookup(name,
        let ifPresent = fun(resource :HttpResource) {
	  resource.asDirectoryContentsResource.isNotNil ? {
	    resource.asDirectoryContentsResource.contents.exists
	      ? { resource } : { nil }
	  } : { resource }	  
	},
        let ifAbsent = fun() {
	  let new = newResource(_dir, name),
	  new.parent := self,
	  new}),
      resource.isNotNil ? {
	_children[name] := resource
      }
    }, fun( :Exception) {}
    )
  }),      
  keys.close
}

_modified :Void
{
  _stamp := Long.MIN_VALUE
}

parentUrl(path :String) :String
{
  let i = path.locateLastChar1('/', let before = (0).max(path.size-1)),
  i.isNotNil
    ? { path.subString(0,i+1) }
    : { nil }
}

;


