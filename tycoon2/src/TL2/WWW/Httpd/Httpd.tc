class Httpd

super Http

public

root :HttpRootResource,		(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
 the root of the resource tree *)
errorLog :Output,		(* where to log error (and debug?) output *)
accessLog :HttpdAccessLog	(* standard web server access log *)

methods

home :String { _properties.home } (* the home location containing config and log subdirs *)

"home:="(home_ :String) :String { _properties.home := home_ }

port :Int { _properties.port }
host :String { _properties.host }
user :String { _properties.user }
group :String { _properties.group }
documentRoot :String { _properties.documentRoot }
url :URL { _properties.url }

bind
{
  _socket.isNil ? {
    let ipadr = host.isNil || { host = "localhost" } ? {
      IPAddress.localHost
    } : {
      host = Httpd.anyHost ? { nil } : { IPAddress.byName(host) }
    },
    _socket := ServerSocket.new(ipadr, port, 20)
  } 
}

serve
{
  _shutdown := false,

  errorLog << "Serving requests at " << _socket.address << ":" << _socket.port << '\n',
  
  while({!_shutdown}, {
    try({
      let conn = _socket.accept,
      handle(conn)},
     fun(e :Exception) {
      try({ errorLog << "Error accepting connection: " << e << '\n' },
        fun(e :Exception) {
          tycoon.stdout << "Error while logging error: " << e << '\n' })})
  }),
  
  errorLog.writeln("Server shutdown")
}

handle(conn :StreamSocket)
{
  let in = conn.bufferedInput,
  let out = conn.bufferedOutput,
  let var request :HttpRequest = nil,

  let response :HttpResponse = try({
  
    request := parseRequest(in),
    request.connectedAddress := conn.remoteAddress,
    let resource = pathLookup(request),
    resource.process(request)
    },
    fun(e :Exception) {
      e.clazz == HttpdError
        ? { let e :HttpdError = _typeCast(e), e.response }
	: { serverResponse("Exception", HttpResponse.INTERNAL_SERVER_ERROR, e.printString) }
    }),
  response.setHeaderValue("Server", MimeString, "HoxHttp/0.1"),

  conn.isOpen ? { (* a commit/restart may have 'closed' the socket *)
    try({
      response.emit(out),
      out.flush
    },
    fun(e :Exception) {
      try({
        errorLog << "Ignoring Exception while emitting response: " << e << '\n'
      }, fun(e :Exception) {
            tycoon.stdout << "Error while logging error: " << e << '\n'
      })
    }),

    request.isNotNil ? {
      try({
        accessLog.log(conn, request, response)
      }, fun(e :Exception) {
        tycoon.stdout << "Error while logging request: " << e << '\n'
      })
    }
  },
 conn.close,
 tycoon.debug || {Resource.allOpenResources.size > 20} ? {
   try({
      let resources =
        List.fromReader(Resource.allOpenResources.map(
	  fun(wr :WeakRef(Resource)){wr.value})),
      let n = resources.size,
      n > 20 ? {
        errorLog << "### " << n << " open resources:\n",
	resources.do(
	  fun(resource :Resource) {
	    errorLog << " " << resource << "\n"
	  })
      }
   }, fun(e :Exception) {
     tycoon.stdout << "Exception while printing open resource list: " << e << '\n'
   })     
  }
}

shutdown(request :HttpRequest) :HttpResponse
  (* shutdown the server. wait until any running requests except the given one (which
     announced the shutdown ##prevent deadlock with multiple simultanious shutdowns)
     are processed.
     answer a HttpResponse reflecting wheter the server is ready and will actually shut down
     after answering the given request (status HttpResponse.OK),
     or some error occured (status ?).
   *)
{
  _shutdown := true,
  (*##no other threads, currently (8-( *)
  serverResponse("Server Shutdown", HttpResponse.OK, "The server is going down.") 
}

commit
  (* savepoint the server. wait until any running requests except the given one (which
     announced the shutdown ##prevent deadlock with multiple simultanious shutdowns)
     are processed.
   *)
{
  errorLog.writeln("Server Savepoint"),
  
  (*##introduce moving target resources? *)
(*  _socket.isNotNil ? {
    _socket.close,
    _socket := nil
  }, *)
  _closeLogs,

  tycoon.commit(
    (* ifCommitted *) {
      _openLogs,
      bind
    },
    (* ifRolledBack *) {
      _openLogs,
      bind
    },
    (* ifRestarted *) { _restarted }
  )
}

serverResponse(title :String, status :Int, text :String) :HttpResponse
{
  let response = HttpResponse.new6(1, 1, status,
    HttpResponse.status(status),
    MimeHeaderDictionary.new,
    nil),
  response.withHtmlGenerator(fun(out :HtmlGenerator) {
    out.title({out.writeString(title)}),
    out.h1({out.writeString(title)}),
    out.p({out.writeString(text)})
  }),
  response
}

error(title :String, status :Int, text :String) :Nil
{
  HttpdError.new(serverResponse(title,status,text)).raise
}

checkAuthorizationForPath(path :String, authorization :HttpCredentials) :Bool
(* return true if authorization authenticates path *)
{
  let request =
    HttpRequest.new6("GET", path, 1, 1, MimeHeaderDictionary.new, nil),
  request.authorization := authorization,
  try({
    let resource = pathLookup(request),
    resource.isNil ? { false } : {
      resource.get(request).statusCode !== HttpResponse.UNAUTHORIZED
    }
  }, fun(:Exception) { false })
}

configure :Void
  require home.isNotNil
{
  _socket.isNotNil ? {
    _socket.close,
    _socket := nil
  }, 

  _properties.load,
  
  _openLogs,

  errorLog << "Configuration loaded from \"" << _properties.path << "\"\n",

  _changeOwners,
  _changeGroup,
  _changeUser,
  _changeRoot,

  root.documentRoot := documentRoot,
  
  bind
}

saveConfiguration
{
  _properties.save,
  errorLog << "Configuration saved to \"" << _properties.path << "\"\n"
}

private

_properties :HttpdProperties,
_socket :ServerSocket,
_shutdown :Bool (*##do this better with STML!*)

methods

_init :Void
{
  _shutdown := false,
  _properties := HttpdProperties.new,
  errorLog := HttpdErrorLog.new(tycoon.stdout),
  accessLog := HttpdAccessLog.new(tycoon.stdout),
  root := HttpRootResource.new(nil),
  super._init
}

parseRequest(in :Input) :HttpRequest
{
  let request = HttpRequest.new,
  request.parser.parse(in, request),
  request
}


pathLookup(request :HttpRequest) :HttpResource
{
  let arcs = request.url.arcs,
  let resource = root.pathLookup(request, arcs),
  resource.isNotNil ? { resource } : { notFound(request) }
}

notFound( :HttpRequest) :Nil
{
  error("Not Found",
    HttpResponse.NOT_FOUND,
    "The requested object does not exist on this server.")
}


_usage
{
  tycoon.stdout << "Usage: tycoon2 store serverHome\n",
  _abort(Httpd.EXIT_USAGE)
}

_restarted
{
  let argv = tycoon.argv,
  argv.size != 2 ? { _usage },

  home := argv[1],

  !Directory.new(home).exists ? { _usage },

  _writePID,

  try({ configure }, fun(e :Exception) {
    errorLog << e << '\n',
    _abort(Httpd.EXIT_BAD_CONFIGURATION)
  }),
  
  errorLog << "Server re-started, serving requests at " << _socket.address << ":" << _socket.port << '\n',
  tycoon.stdout << "Serving requests ..." << '\n'
}


_writePID
{
  let pidLog = File.new(_pidPath),
  pidLog.exists ? {
    pidLog.openRead,
    let pid = Int.fromReader(pidLog),
    pidLog.close,
    try({ tycoon.os.signal(pid, tycoon.os.SIGTESTPID),
	  tycoon.stdout << "Server already running.\n",
	  tycoon.stdout.flush,
	  _exit(99)
	 }, 
      fun( :Exception) {
    })    
  },
  pidLog.openWrite,
  pidLog << tycoon.os.pid.printString,
  pidLog.close
}

_removePID
{
  let pidLog = File.new(_pidPath),
  pidLog.exists ? {
    pidLog.remove
  }
}

_exit(code :Int)
{
  _removePID,
  tycoon.ansiC.exit(code)
}

_abort(code :Int)
{
  tycoon.stdout << "Tycoon Web Server aborted.\nSee " << _errorLogPath << " for more information\n",
  tycoon.stdout.flush,
  _exit(code)
}

_tryAndAbort(msg :String, statement :Fun0(Void))
{
  try({ statement[] },
    fun(e :Exception) {
      errorLog << msg << ": " <<
        (e.clazz == OSError || { e.clazz == IOError }
	   ? { _typeCast(e, :OSError).msg }
	   : { e.printString }),
      errorLog.nl,
      _abort(Httpd.EXIT_BAD_CONFIGURATION)
    })
}

_changeOwners
{
  tycoon.os.fs.clazz == PosixFS ? {
    let fs = _typeCast(tycoon.os.fs, :PosixFS),
    let var uid = _userId,
    uid.isNil ? { uid := -1 },
    let var gid = _groupId,
    gid.isNil ? { gid := -1 },
    _changeOwners1(fs, uid, gid)
  }
}

_changeOwners1(fs :PosixFS, uid :Int, gid :Int)
{
  _changeOwner(fs, _errorLogPath, uid, gid),
  _changeOwner(fs, _accessLogPath, uid, gid),
  _changeOwner(fs, _pidPath, uid, gid)
}

_changeOwner(fs :PosixFS, path :String, uid :Int, gid :Int)
{
  File.new(path).exists ? {
    try({
      fs.chown(path, uid, gid)
    }, fun(e :Exception) {
      try({
	errorLog.writeln("Ignoring exception while changing owner of "+path+"\n"+
	  e.printString)
      }, fun(:Exception) { tycoon.stdout.writeln("Error while logging error") })
    })
  }
}

_userId :Int
{
  user.isNil ? fun() :Int { nil } : {
    let uid = tycoon.os.user2uid(user),
    uid.isNil ? {
      errorLog << "No such user: \'" << user << "\'\n",
      _abort(Httpd.EXIT_BAD_CONFIGURATION),
      0
    } : { uid }
  }
}

_groupId :Int
{
  group.isNil ? fun() :Int { nil } : {
    let gid = tycoon.os.group2gid(group),
    gid.isNil ? {
      errorLog << "No such group: \'" << group << "\'\n",
      _abort(Httpd.EXIT_BAD_CONFIGURATION),
      0
    } : { gid }
  }
}

_changeUser
{
  let uid = _userId,
  uid.isNotNil ? {
    _tryAndAbort("Cannot change user id to " + user + "(" + uid.printString + ")",
      fun(){ tycoon.os.uid := uid
    })
  }
}

_changeGroup
{
  let gid = _groupId,
  gid.isNotNil ? {
    _tryAndAbort("Cannot change group to " + group + "(" + gid.printString + ")", fun(){
      tycoon.os.gid := gid
    })
  }
}

_changeRoot
  (*##implement change root 'feature'? (s. Apache, Netscape servers) *)
{
}

_configFilePath :String
{
  tycoon.os.fs.composePath(List.with3(home, "conf", "tyhttpd.conf"))
}

_errorLogPath :String
{
  tycoon.os.fs.composePath(List.with3(home, "log", "error.log"))
}

_accessLogPath :String
{
  tycoon.os.fs.composePath(List.with3(home, "log", "access.log"))
}

_pidPath :String
{
  tycoon.os.fs.composePath(List.with3(home, "log", "tyhttpd.pid"))
}

_openLogs
{
  errorLog := HttpdErrorLog.new(File.open(
    _errorLogPath, File.O_CREAT | File.O_WRONLY | File.O_APPEND, 0)),
  accessLog.out := File.open(
    _accessLogPath, File.O_CREAT | File.O_WRONLY | File.O_APPEND, 0).bufferedOutput
}

_closeLogs
{
  errorLog.isNotNil ? {
    errorLog.close,
    errorLog := nil
  },
  accessLog.isNotNil && { accessLog.out.isNotNil } ? {
    accessLog.out.close,
    accessLog.out := nil
  }
}


;
