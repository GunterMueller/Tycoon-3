(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *

  Some useful constructs for parsing MIME

  Author: Matthias Ernst 12/96
*)

class MimeParser
super Mime

public methods

init(r :Reader(Char)) {
  _r := r,
  _char := _r.read
}

(* the next character in the input, NOT consuming *)
char :Char {
  _char
}

next :Char {
  _char := _r.read
}

reader :Reader(Char) {
  Reader.cons(_char, _r)
}

(* Added value *)

skip(c :Char) {
  char = c ? {
    next
  } : {
    MimeParserError.new("Expected "+c.printString+", got "+char.printString).raise
  }
}

(* horizontal whitespace *)
skiphws {
  while({
    char = ' ' | char = '\t'
  }, {
    next
  })
}

skipws {
  while({
    char = ' ' | char = '\t' | char = '\n' | char = '\r'
  }, {
    next
  })
}

(* HTTP *)
nextToken :String {
  let s = GapString.new(10),

  while({
    char != nil &&
    { isCHAR(char) } && { !isCTL(char) } && { !isTspecial(char) }
  }, {
    s.add(char),
    next
  }),

  s.size = 0 ? { MimeParserError.new("No token").raise },

  s.asString
}

nextQuoted :String {
  let s = GapString.new(10),

  skip('\"'),
  s.add('\"'),
  
  while({
    char != '\"'
  }, {
    char == nil ? { MimeParserError.new("Premature end of quoted string").raise },
    char == '\\' ? {
      s.add(char),
      next,
      char == nil ? { MimeParserError.new("Premature end of quoted string").raise },
      s.add(char),
      next
    },
      
    isCTL(char) ? { MimeParserError.new("CTL in quoted string").raise },
    s.add(char),
    next
  }),

  skip('\"'),
  s.add('\"'),

  s.asString
}

nextWord :String {
  skipws,

  char = '\"' ? { nextQuoted } : { nextToken }
}

nextWordUnquoted :String {
  skipws,

  char = '\"' ? { nextUnquoted } : { nextToken }
}

nextUnquoted :String {
  let result = GapString.new(10),
  
  skip('\"'),
  let var break = false,
  while({!break}, {
    char = nil  ? { MimeParserError.new("Premature end of quote").raise } : {
    char = '\"' ? { next, break := true, nil } : {
    char = '\\' ? {
      next,
      char = nil ? { MimeParserError.new("Premature end of quote").raise },
      result.add(char),
      next, nil
    } : { (* else *)
    result.add(char),
    next, nil
    }}}}
  ),

  result.asString
}

nextDigits :String
{
  let digits = GapString.new(3),
  while({isDIGIT(char)}, {
    digits.add(char),
    next
  }),

  digits.asString
}

(* see the HTTP-1.1 spec *)
isCHAR(c :Char) :Bool { (c >= '\000') & (c <= '\127') }
isCTL(c :Char) :Bool { ((c >= '\000') & (c <= '\031')) | (c = '\127') }
isTspecial(c :Char) :Bool { "()<>@,;:\\\"/[]?={} \t".includes(c) }
isDIGIT(c :Char) :Bool { (c >= '0') & (c <= '9') }

private

_r :Reader(Char),
_char :Char

;
