class X_TL2Root
super Object
(*
 * This file is part of the Tycoon-2 system.
 *
 * The Tycoon-2 system is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation (Version 2).
 *
 * The Tycoon-2 system is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public
 * License along with the Tycoon-2 system; see the file LICENSE.
 * If not, write to AB 4.02, Softwaresysteme, TU Hamburg-Harburg
 * D-21071 Hamburg, Germany. (http://www.sts.tu-harburg.de)
 * 
 * Copyright (c) 1996-1998 Higher-Order GmbH, Hamburg. All rights reserved.
 *
threads :List(Thread),         [* circular list of threads *]*)
meta X_TL2RootClass
{
thread :Thread(Void)

classTable :MutableArray(X_TL2Class)
  (* mapping class ids to class objects *)

selectorTable :MutableArray(X_TL2Selector)
  (* numbering for selectors in message sends *)

true_  :Object
  (* the object interpreted and used as true by the machine.
     The slot type currently cannot be :True, because there is no mapping
     from tsp_Field_OID to Tycoon booleans. *)

false_ :Object
  (* the object interpreted and used as false by the machine.
     The slot type currently cannot be :False, because there is no mapping
     from tsp_Field_OID to Tycoon booleans. *)

nil_ :Nil

charTable :Array(Char)

symbolTable :Set(Symbol)

selectorTableSize :Int

nextClassId :Int

finalizer :Finalizer

storeDescriptors :Dictionary(String, X_TL2TspDescriptor)
  (* class name --> X_TL2TspDescriptor *)

active :Bool
  (* is this the current machine's root object? *)

debugger :X_TL2Debugger
  (* the handler for events generated by the machine *)

newSelectorId(selector :X_TL2Selector) :Int
  (* *)
{
  ; handmade GapArrays 
  i ::= selectorTableSize
  if( selectorTable.size = i then: {
    newSelectorTable ::= MutableArray.new(2*i)
    newSelectorTable.replace(i, 0, selectorTable, 0)
    selectorTable := newSelectorTable
  })
  selectorTable[i] := selector
  selectorTableSize := selectorTableSize + 1
  i
}

selectors :FunSequence(X_TL2Selector)
  (* *)
{
  FunSequence.new(
    selectorTable,
    { selectorTableSize })
}

registerClass(class_ :X_TL2Class) :Void
  (* *)
{
  desc ::= class_.storeDescriptor
  class_.id := newClassId(desc.layout, desc.format)

  ; handmade GapArrays 
  if( class_.id >= classTable.size then: {
    newSize ::= (class_.id+1).max(2 * classTable.size)
    newClassTable ::= MutableArray.new(newSize)
    newClassTable.replace(classTable.size, 0, classTable, 0)
    classTable := newClassTable
  })
  classTable[class_.id] := class_
}

classes :Reader(X_TL2Class)
  (* *)
{ classTable.keys
     .select(fun(i:Int){ classTable[i].isNotNil })
     .map(fun(i:Int){ classTable[i] })
}

flushAll :Void
  (* method cache: *)
{ if( active then: { _flushAll }) }

flushClass(c :X_TL2Class) :Void
  (* *)
{ if( active then: { _flushClass(c) }) }

flushSingle(c :X_TL2Class, selector :Int) :Void
  (* *)
{ if( active then: { _flushSingle(c, selector) }) }

private

_init :Void
  (* *)
{ super._init

  ; ### threads := EmptyList.new, 

  symbolTable := Set.new
  
  classTable := MutableArray.new(10)
  nextClassId := 0

  selectorTable := MutableArray.new(10)
  selectorTableSize := 0

  true_ := true
  false_ := false
  ma ::= MutableArray.new(256)
  ma.keys.do(fun(i :Int) {
    ma[i] := i.asChar
  })
  charTable := Array.fromSequence(ma)
  active := false
  self
}

newClassId(layout :Int, descriptor :String) :Int
  (* *)
{
  if( active
  then: { _newClassId(layout, descriptor) }
  else: { result ::= nextClassId
      nextClassId := nextClassId+1
      result })
}

_newClassId(layout :Int, descriptor :String) :Int
  (* *)
builtin

_flushAll :Void
  (* *)
builtin

_flushClass(c :X_TL2Class) :Void
  (* *)
builtin

_flushSingle(c :X_TL2Class, selector :Int) :Void
  (* *)
builtin

}
